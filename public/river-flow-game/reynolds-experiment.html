<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Zittau's Reynolds Challenge</title>
    <style>
        :root {
            --cyan-300: #67e8f9;
            --cyan-400: #22d3ee;
            --gray-400: #9ca3af;
            --gray-600: #4b5563;
            --gray-700: #374151;
            --gray-800: #1f2937;
            --gray-900: #111827;
            --yellow-400: #facc15;
            --green-400: #4ade80;
            --red-400: #f87171;
            --blue-400: #60a5fa;
            --grass-dark: #3a7d44;
            --grass-light: #4a9d56;
            --concrete-light: #aab2b8;
            --concrete-dark: #848b91;
            --obstacle-color: #6b4f3a; /* Brown for obstacles */
        }
        @keyframes gradient-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(34, 211, 238, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(34, 211, 238, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 211, 238, 0); }
        }
        body { 
            margin: 0; 
            color: white;
            display: flex; 
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            overflow: hidden;
            padding: 1rem;
            box-sizing: border-box;
            background: linear-gradient(-45deg, #111827, #1f2937, #1f3a47, #111827);
            background-size: 400% 400%;
            animation: gradient-animation 15s ease infinite;
        }
        #game-view, .app-container {
            width: 100%;
            max-width: 64rem;
            margin: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        #game-view {
            display: none; /* Initially hidden */
        }
        .simulation-frame {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 1024px;
            aspect-ratio: 16 / 10;
            max-height: 80vh;
            border-radius: 0.5rem;
            overflow: hidden;
            background: var(--grass-dark);
            padding: 1rem;
            box-sizing: border-box;
            border: 2px solid var(--gray-700);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
        }
        .grass {
            background-color: var(--grass-dark);
            background-image: 
                repeating-linear-gradient(45deg, transparent, transparent 3px, var(--grass-light) 3px, var(--grass-light) 6px),
                repeating-linear-gradient(-45deg, transparent, transparent 3px, var(--grass-light) 3px, var(--grass-light) 6px);
            background-size: 10px 10px;
        }
        .grass-top { height: 5%; }
        .grass-bottom { height: 5%; }
        .middle-section {
            display: flex;
            flex-grow: 1;
            height: 90%;
        }
        .canal {
            width: 7%;
            background-color: var(--concrete-light);
            border-right: 4px solid var(--concrete-dark);
            box-shadow: inset 5px 0 10px rgba(0,0,0,0.2);
            position: relative;
        }
        .canal::before, .canal::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            background: var(--concrete-dark);
            height: 25%;
        }
        .canal::before { top: 0; }
        .canal::after { bottom: 0; }
        .canal.canal-outflow {
            border-right: none;
            border-left: 4px solid var(--concrete-dark);
            box-shadow: inset -5px 0 10px rgba(0,0,0,0.2);
        }
        .canvas-container { 
            position: relative;
            flex-grow: 1;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            cursor: crosshair;
        }
        canvas { 
            display: block;
            width: 100%; 
            height: 100%;
            object-fit: contain; 
        }
        #info { 
            position: absolute; 
            top: 0.75rem; 
            left: 0.75rem; 
            background: rgba(17, 24, 39, 0.6); 
            color: white; 
            padding: 1rem; 
            border-radius: 0.5rem; 
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
            backdrop-filter: blur(8px);
            border: 1px solid var(--gray-700);
            font-size: 0.875rem;
            font-family: monospace;
            pointer-events: none;
        }
        #info p { margin: 0 0 0.25rem 0; }
        #info p:last-child { margin-bottom: 0; }
        #info .flow-state-stable { color: var(--green-400); }
        #info .flow-state-unstable { color: var(--yellow-400); }
        #info .flow-state-chaotic { color: var(--red-400); }
        #info .font-semibold { font-weight: 600; }
        .controls-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background-color: var(--gray-800);
            border-radius: 0.5rem;
            border: 1px solid var(--gray-700);
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
            width: 100%;
            box-sizing: border-box;
        }
        .btn {
            background-color: var(--gray-700);
            border: 1px solid var(--gray-600);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }
        .btn:hover { background-color: var(--gray-600); }
        .btn:active { transform: scale(0.95); }
        .btn.active {
             background-color: var(--cyan-400);
             color: var(--gray-900);
             border-color: var(--cyan-300);
        }
        .btn:disabled {
            background-color: var(--gray-800);
            color: var(--gray-600);
            cursor: not-allowed;
            border-color: var(--gray-700);
        }

        /* --- Welcome Screen --- */
        #welcome-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        .welcome-panel {
            background: rgba(31, 41, 55, 0.6);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--gray-700);
            border-radius: 1rem;
            padding: 3rem;
            max-width: 600px;
            width: 100%;
            text-align: center;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
            animation: fadeIn 0.8s ease-out forwards;
            opacity: 0;
        }
        .welcome-panel h1 {
            color: var(--cyan-300);
            margin-top: 0;
            font-size: 2.75rem;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(34, 211, 238, 0.3);
        }
        .welcome-panel p {
            margin-bottom: 2.5rem;
            font-size: 1.1rem;
            color: var(--gray-400);
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }
        .welcome-panel .controls-container {
            background: none;
            border: none;
            box-shadow: none;
            padding: 0;
            gap: 1rem;
        }
        .btn-primary {
            background-color: var(--cyan-400);
            color: var(--gray-900);
            border-color: var(--cyan-300);
            padding: 0.75rem 2rem;
            font-size: 1rem;
            animation: pulse 2s infinite;
            transition: all 0.3s ease;
        }
        .btn-primary:hover {
            background-color: var(--cyan-300);
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 20px rgba(34, 211, 238, 0.2);
        }
        .btn-secondary {
            background-color: transparent;
            color: var(--cyan-300);
            border: 1px solid var(--gray-600);
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        .btn-secondary:hover {
            background-color: var(--gray-700);
            border-color: var(--cyan-400);
            transform: translateY(-3px);
        }
        #lang-switcher {
            margin-top: 1.5rem;
            padding: 0.5rem;
            background: rgba(17, 24, 39, 0.5);
            border-radius: 0.5rem;
        }

        /* --- Modal and UI Styles --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(17, 24, 39, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 1rem;
            box-sizing: border-box;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: var(--gray-800);
            padding: 2rem;
            border-radius: 0.5rem;
            border: 1px solid var(--gray-700);
            max-width: 500px;
            text-align: center;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal-content h2, .modal-content h3 {
            margin-top: 0;
            color: var(--cyan-300);
        }
        .modal-content p {
            line-height: 1.6;
            margin-bottom: 1rem;
        }
        .modal-content .btn {
            margin-top: 1rem;
        }
        .modal-content .btn-primary, .modal-content .btn:not(.btn-secondary) {
            background-color: var(--cyan-400);
            color: var(--gray-900);
            border-color: var(--cyan-300);
        }
        .modal-content .controls-container {
            background: none; box-shadow: none; border: none; padding: 0.5rem 0;
        }
        .modal-content strong {
            color: var(--yellow-400);
        }
        .modal-content .instruction-text {
            color: var(--yellow-400);
        }
        #timer {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            font-size: 2rem;
            font-weight: bold;
            color: var(--yellow-400);
            background: rgba(17, 24, 39, 0.6);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
            display: none;
        }
        .lang-btn {
            padding: 0.5rem;
            min-width: 40px;
            background-color: var(--gray-800);
            border: 1px solid var(--gray-700);
            transition: all 0.3s ease;
        }
        .lang-btn:hover {
            background-color: var(--gray-700);
            color: white;
        }
        .lang-btn.active {
            background-color: var(--cyan-400);
            color: var(--gray-900);
            border-color: var(--cyan-300);
        }
    </style>
</head>
<body>
    <div id="welcome-screen">
        <div class="welcome-panel">
            <h1 data-t="welcomeModal.title">Zittau's Reynolds Challenge</h1>
            <p data-t="welcomeModal.desc">An interactive game about fluid dynamics, inspired by the Mandau river.</p>
            <div class="controls-container">
                <button id="start-game-btn" class="btn btn-primary" data-t="welcomeModal.startBtn">Start Game</button>
                <button id="learn-btn" class="btn btn-secondary" data-t="welcomeModal.learnBtn">Learn How Water Flows</button>
                <button id="ranking-btn" class="btn btn-secondary" data-t="welcomeModal.rankingBtn">Ranking</button>
            </div>
            <div id="lang-switcher" class="controls-container">
                <button class="btn lang-btn active" data-lang="en">EN</button>
                <button class="btn lang-btn" data-lang="de">DE</button>
                <button class="btn lang-btn" data-lang="pl">PL</button>
                <button class="btn lang-btn" data-lang="cz">CZ</button>
            </div>
        </div>
    </div>

    <div id="game-view">
        <div class="app-container">
            <main class="simulation-frame">
                <div class="grass grass-top"></div>
                <div class="middle-section">
                    <div id="canal-div" class="canal"></div>
                    <div class="canvas-container">
                        <canvas id="fluid-canvas"></canvas>
                        <div id="info"></div>
                        <div id="timer">10</div>
                    </div>
                    <div id="outflow-div" class="canal canal-outflow"></div>
                </div>
                <div class="grass grass-bottom"></div>
            </main>
            
            <footer id="main-controls" class="controls-container">
                <button id="decrease-flow" class="btn" data-t="mainControls.decreaseFlow">Decrease Flow</button>
                <button id="increase-flow" class="btn" data-t="mainControls.increaseFlow">Increase Flow</button>
                <button id="pause-sim" class="btn" data-t="mainControls.pause">Pause</button>
                <button id="toggle-pressure" class="btn" data-t="mainControls.showPressure">Show Pressure</button>
                <button id="submit-velocity-btn" class="btn" data-t="mainControls.submitVelocity">Submit Velocity</button>
            </footer>

            <div id="build-controls" class="controls-container" style="display: none;">
                <button id="build-channel-btn" class="btn" data-t="buildControls.buildChannel">Build Channel</button>
                <button id="clear-obstacles-btn" class="btn" data-t="buildControls.clearObstacles">Clear Obstacles</button>
                <button id="flow-btn" class="btn" data-t="buildControls.goWithFlow">Go with the Flow!</button>
            </div>

            <div id="pressure-legend" class="controls-container" style="display: none; justify-content: flex-end; font-size: 0.8rem; padding: 0.5rem 1rem; background: var(--gray-900); border: 1px solid var(--gray-700);">
                <span style="display: flex; align-items: center; margin-right: 1rem;">
                    <span style="width: 12px; height: 12px; background-color: var(--red-400); border-radius: 50%; margin-right: 0.5rem;"></span>
                    <span data-t="legend.highPressure">High Pressure</span>
                </span>
                <span style="display: flex; align-items: center;">
                    <span style="width: 12px; height: 12px; background-color: var(--blue-400); border-radius: 50%; margin-right: 0.5rem;"></span>
                    <span data-t="legend.lowPressure">Low Pressure</span>
                </span>
            </div>
        </div>
    </div>
    
    <!-- MODALS -->
    <div id="learn-modal" class="modal-overlay"><div class="modal-content" style="max-width: 700px; text-align: left;"><div id="learn-selection"><h3 data-t="learnModal.title">Learn How Water Flows</h3><p data-t="learnModal.desc">Choose your level of detail to learn about the physics of fluids.</p><div class="controls-container"><button id="learn-beginner-btn" class="btn" data-t="learnModal.beginnerBtn">Beginner</button><button id="learn-advanced-btn" class="btn" data-t="learnModal.advancedBtn">Advanced</button></div></div><div id="learn-content" style="display: none;"><h3 id="learn-title"></h3><div id="learn-text"></div></div><button id="learn-back-btn" class="btn" data-t="learnModal.backBtn" style="margin-top: 1.5rem;">Back</button></div></div>
    
    <div id="intro-modal" class="modal-overlay"><div class="modal-content"><h2 data-t="introModal.title">Welcome to the Reynolds Challenge!</h2><p class="instruction-text" data-t="introModal.desc1">Your goal is to create turbulence by increasing the water's velocity. Use the "Increase Flow" button to speed up the water.</p><p class="instruction-text" data-t="introModal.desc2">You have <strong>10 seconds</strong> to reach a velocity of <strong>200</strong> or more.</p><button id="start-btn" class="btn" data-t="introModal.startBtn">Start Experiment</button></div></div>
    <div id="info-popup-velocity" class="modal-overlay"><div class="modal-content"><h3 data-t="velocityInfoModal.title">Observe the Turbulence</h3><p class="instruction-text" data-t="velocityInfoModal.desc">Notice how the smooth dye stream broke apart into swirls and eddies? That's <strong>turbulence</strong>! You will now have 5 seconds to observe.</p><button id="close-velocity-popup-btn" class="btn" data-t="velocityInfoModal.nextBtn">Next Lesson</button></div></div>
    <div id="pressure-intro-modal" class="modal-overlay"><div class="modal-content"><h2 data-t="pressureIntroModal.title">The Role of Pressure</h2><p class="instruction-text" data-t="pressureIntroModal.desc1">Turbulence isn't just about velocity; it's driven by chaotic pressure changes. High-pressure zones push fluid into low-pressure zones, creating the swirls you saw.</p><p class="instruction-text" data-t="pressureIntroModal.desc2">Your next task: Recreate the turbulent flow from memory. Set the velocity back to <strong style="font-size: 1.2rem;"><span id="target-velocity-display"></span></strong> and press 'Submit'.</p><button id="start-pressure-challenge-btn" class="btn" data-t="pressureIntroModal.startBtn">Start Pressure Challenge</button></div></div>
    <div id="info-popup-pressure" class="modal-overlay"><div class="modal-content"><h3 data-t="pressureInfoModal.title">The 'Engine' of Turbulence</h3><p class="instruction-text" data-t="pressureInfoModal.desc">You're now seeing the <strong>pressure field</strong>. Red areas have high pressure, and blue areas have low pressure.</p><p class="instruction-text" data-t="pressureInfoModal.desc2">Think of it like hills and valleys. Water rushes from the high-pressure 'hills' to the low-pressure 'valleys'. In a turbulent flow, these hills and valleys form and disappear chaotically, creating the swirling eddies you saw with the dye. This constant, unstable pressure difference is the true engine driving turbulence.</p><p class="instruction-text" data-t="pressureInfoModal.desc3">Well done! Observe this for 5 seconds before the final challenge.</p><button id="close-pressure-popup-btn" class="btn" data-t="pressureInfoModal.nextBtn">Final Challenge</button></div></div>
    <div id="fail-modal" class="modal-overlay"><div class="modal-content"><h2 data-t="failModal.title">Challenge Failed</h2><p data-t="failModal.velocityDesc">You didn't increase the velocity enough in 10 seconds to create strong turbulence! A velocity of 200 or more is required.</p><button id="try-again-btn" class="btn" data-t="failModal.tryAgainBtn">Try Again</button></div></div>
    <div id="fail-modal-pressure" class="modal-overlay"><div class="modal-content"><h2 data-t="failModal.title">Challenge Failed</h2><p data-t="failModal.pressureDesc">You didn't match the target velocity closely enough. The goal is to develop an intuitive feel for the flow's speed and appearance.</p><p><span data-t="failModal.yourVelocity">Your Velocity:</span> <strong style="color: var(--red-400);"><span id="your-velocity-display"></span></strong> | <span data-t="failModal.target">Target:</span> <strong style="color: var(--green-400);"><span id="target-velocity-display-pressure-fail"></span></strong></p><button id="try-again-pressure-btn" class="btn" data-t="failModal.tryAgainBtn">Try Again</button></div></div>
    <div id="obstacle-fail-modal" class="modal-overlay"><div class="modal-content"><h2 data-t="obstacleFailModal.title">Channel Blocked!</h2><p class="instruction-text" data-t="obstacleFailModal.desc">It looks like your channel is blocking the inlet or outlet, preventing water from flowing through. An open path is needed for a successful design!</p><button id="try-again-obstacle-btn" class="btn" data-t="obstacleFailModal.tryAgainBtn">Try Building Again</button></div></div>
    <div id="obstacle-intro-modal-3" class="modal-overlay"><div class="modal-content"><h2 data-t="obstacleModals.title3">Challenge 3: Build a River Bank</h2><p class="instruction-text" data-t="obstacleModals.desc3">Your task is to build an efficient channel to guide the water from the inlet on the left to the outlet at the bottom. Aim for the highest possible outlet-to-inlet velocity ratio!</p><button id="start-building-3-btn" class="btn" data-t="obstacleModals.startBtn">Start Building</button></div></div>
    <div id="obstacle-intro-modal-4" class="modal-overlay"><div class="modal-content"><h2 data-t="obstacleModals.title4">Challenge 4: Split the Flow</h2><p class="instruction-text" data-t="obstacleModals.desc4">Now, build a channel that splits the flow to outlets at both the top and bottom. Maximize the combined flow ratio!</p><button id="start-building-4-btn" class="btn" data-t="obstacleModals.startBtn">Start Building</button></div></div>
    <div id="obstacle-intro-modal-5" class="modal-overlay"><div class="modal-content"><h2 data-t="obstacleModals.title5">Final Challenge: Triple Threat</h2><p class="instruction-text" data-t="obstacleModals.desc5">The ultimate test: Channel the water to three outlets (top, bottom, and right). Design the most efficient system to maximize the flow ratio.</p><button id="start-building-5-btn" class="btn" data-t="obstacleModals.startBtn">Start Building</button></div></div>
    <div id="level-win-modal" class="modal-overlay"><div class="modal-content"><h2 data-t="winModal.levelComplete">Level Complete!</h2><p><span data-t="winModal.flowRatio">Your Flow Ratio:</span> <strong id="level-flow-ratio-display"></strong></p><div class="controls-container"><button id="retry-level-btn" class="btn btn-secondary" data-t="winModal.retryBtn">Try Again</button><button id="next-level-btn" class="btn" data-t="winModal.nextLevelBtn">Next Level</button></div></div></div>
    <div id="win-modal" class="modal-overlay"><div class="modal-content"><h2 data-t="winModal.congrats">Congratulations!</h2><div><p><span data-t="winModal.totalTime">Total Time:</span> <strong id="total-time-display"></strong></p><p><span data-t="winModal.finalFlowRatio">Final Flow Ratio:</span> <strong id="flow-ratio-display"></strong></p></div><button id="play-again-btn" class="btn" data-t="winModal.playAgainBtn">Play Again</button></div></div>


    <script>
        // --- Simulation Constants ---
        const U_FIELD = 0, V_FIELD = 1, S_FIELD = 2;

        // --- Internationalization ---
        const translations = {
            en: {
                welcomeModal: { title: "Zittau's Reynolds Challenge", desc: "An interactive game about fluid dynamics, inspired by the Mandau river.", startBtn: "Start Game", learnBtn: "Learn How Water Flows", rankingBtn: "Ranking" },
                learnModal: { title: "Learn How Water Flows", desc: "Choose your level of detail to learn about the physics of fluids.", beginnerBtn: "Beginner", advancedBtn: "Advanced", backBtn: "Back", beginnerTitle: "Beginner's Guide to Water Flow", beginnerText: "<p>Imagine water is like a crowd of people. When they walk slowly, everyone moves in neat, orderly lines. This is called <strong>laminar flow</strong>. It's smooth and predictable.</p><p>But if everyone starts running and bumping into each other, the crowd becomes a chaotic mess. This is <strong>turbulent flow</strong>, full of swirls and eddies. It's much more energetic and unpredictable.</p><h4>The Reynolds Experiment</h4><p>A scientist named Osborne Reynolds did a famous experiment to show this. He injected a thin stream of dye into water flowing in a glass pipe. At low speeds, the dye was a perfect, straight line (laminar). As he increased the speed, the line wobbled and then burst into complex patterns (turbulent). This game lets you recreate his discovery!</p><h4>From River Bends to Straight Channels</h4><p>The Mandau river in Zittau used to be very curvy. While pretty, this can cause problems like washing away river banks (erosion). To protect the city, engineers straightened parts of the river. In the later challenges, you get to be an engineer! You'll build channels to guide the water efficiently, just like they did in the real world.</p>", advancedTitle: "Advanced Fluid Dynamics", advancedText: "<p>The motion of fluids is described by the <strong>Navier-Stokes equations</strong>, a set of complex differential equations. They account for forces like pressure, viscosity (the fluid's internal friction), and inertia (the fluid's tendency to keep moving).</p><h4>The Reynolds Number (Re)</h4><p>Osborne Reynolds quantified the transition from laminar to turbulent flow using a dimensionless quantity, the <strong>Reynolds number (Re)</strong>. It is the ratio of inertial forces to viscous forces within a fluid.</p><p><code>Re = (ρuL) / μ</code>, where ρ is density, u is velocity, L is a characteristic length, and μ is dynamic viscosity.</p><p>A low Re indicates that viscous forces are dominant, resulting in smooth, <strong>laminar flow</strong>. A high Re indicates that inertial forces dominate, leading to chaotic, <strong>turbulent flow</strong>. In this game, increasing the flow's velocity directly raises the Reynolds number.</p><h4>Hydraulic Engineering and the Mandau</h4><p>The straightening of the Mandau river is a classic example of hydraulic engineering. A meandering river has a long path, which can be inefficient for moving large volumes of water during floods. By creating a direct, engineered channel, the flow velocity is managed more effectively, reducing flood risk and bank erosion. The challenges where you build channels to maximize flow ratio are a simplified model of this real-world problem: designing a system to optimize fluid transport.</p>" },
                introModal: { title: "Welcome to the Reynolds Challenge!", desc1: "Your goal is to create turbulence by increasing the water's velocity. Use the 'Increase Flow' button to speed up the water.", desc2: "You have <strong>10 seconds</strong> to reach a velocity of <strong>200</strong> or more.", startBtn: "Start Experiment" },
                velocityInfoModal: { title: "Observe the Turbulence", desc: "Notice how the smooth dye stream broke apart into swirls and eddies? That's <strong>turbulence</strong>! You will now have 5 seconds to observe.", nextBtn: "Next Lesson" },
                pressureIntroModal: { title: "The Role of Pressure", desc1: "Turbulence isn't just about velocity; it's driven by chaotic pressure changes. High-pressure zones push fluid into low-pressure zones, creating the swirls you saw.", desc2: "Your next task: Recreate the turbulent flow from memory. Set the velocity back to <strong style='font-size: 1.2rem;'><span id='target-velocity-display'></span></strong> and press 'Submit'.", startBtn: "Start Pressure Challenge" },
                pressureInfoModal: { title: "The 'Engine' of Turbulence", desc: "You're now seeing the <strong>pressure field</strong>. Red areas have high pressure, and blue areas have low pressure.", desc2: "Think of it like hills and valleys. Water rushes from the high-pressure 'hills' to the low-pressure 'valleys'. In a turbulent flow, these hills and valleys form and disappear chaotically, creating the swirling eddies you saw with the dye. This constant, unstable pressure difference is the true engine driving turbulence.", desc3: "Well done! Observe this for 5 seconds before the final challenge.", nextBtn: "Final Challenge" },
                failModal: { title: "Challenge Failed", velocityDesc: "You didn't increase the velocity enough in 10 seconds to create strong turbulence! A velocity of 200 or more is required.", pressureDesc: "You didn't match the target velocity closely enough. The goal is to develop an intuitive feel for the flow's speed and appearance.", yourVelocity: "Your Velocity:", target: "Target:", tryAgainBtn: "Try Again" },
                obstacleFailModal: { title: "Channel Blocked!", desc: "It looks like your channel is blocking the inlet or outlet, preventing water from flowing through. An open path is needed for a successful design!", tryAgainBtn: "Try Building Again" },
                obstacleModals: { title3: "Challenge 3: Build a River Bank", desc3: "Use your cursor to draw channel walls. Your task is to build an efficient channel to guide water from the <strong style='color: var(--cyan-300)'>inlet on the left</strong> to the <strong style='color: var(--green-400)'>outlet at the bottom</strong>. Aim for the highest possible flow ratio (a higher number is better)!", startBtn: "Start Building", title4: "Challenge 4: Split the Flow", desc4: "Use your cursor to draw channel walls. Now, build a channel that splits the flow from the <strong style='color: var(--cyan-300)'>inlet</strong> to outlets at both the <strong style='color: var(--green-400)'>top and bottom</strong>. Maximize the combined flow ratio!", title5: "Final Challenge: Triple Threat", desc5: "Use your cursor to draw channel walls. The ultimate test: Channel water from the <strong style='color: var(--cyan-300)'>inlet</strong> to three outlets (<strong style='color: var(--green-400)'>top, bottom, and right</strong>). Design the most efficient system to maximize the flow ratio." },
                winModal: { levelComplete: "Level Complete!", flowRatio: "Your Flow Ratio:", nextLevelBtn: "Next Level", retryBtn: "Try Again", congrats: "Congratulations!", totalTime: "Total Time:", finalFlowRatio: "Final Flow Ratio:", playAgainBtn: "Play Again" },
                mainControls: { decreaseFlow: "Decrease Flow", increaseFlow: "Increase Flow", pause: "Pause", play: "Play", showPressure: "Show Pressure", showDye: "Show Dye", submitVelocity: "Submit Velocity" },
                buildControls: { buildChannel: "Build Channel", stopBuilding: "Stop Building", clearObstacles: "Clear Obstacles", goWithFlow: "Go with the Flow!" },
                info: { peakFlow: "Peak Flow:", flowCharacter: "Flow Character:", stable: "Stable", unstable: "Unstable", chaotic: "Chaotic" },
                canvasLabels: { inlet: 'INLET', outlet: 'OUTLET' },
                legend: { highPressure: "High Pressure", lowPressure: "Low Pressure" }
            },
            de: {
                welcomeModal: { title: "Zittaus Reynolds-Herausforderung", desc: "Ein interaktives Spiel über Strömungsdynamik, inspiriert vom Fluss Mandau.", startBtn: "Spiel starten", learnBtn: "Wie Wasser fließt", rankingBtn: "Rangliste" },
                learnModal: { title: "Wie Wasser fließt", desc: "Wähle den Detailgrad, um mehr über die Physik von Flüssigkeiten zu erfahren.", beginnerBtn: "Anfänger", advancedBtn: "Fortgeschritten", backBtn: "Zurück", beginnerTitle: "Anfängerleitfaden zum Wasserfluss", beginnerText: "<p>Stell dir vor, Wasser ist wie eine Menschenmenge. Wenn sie langsam gehen, bewegen sich alle in sauberen, geordneten Linien. Das nennt man <strong>laminare Strömung</strong>. Sie ist glatt und vorhersagbar.</p><p>Aber wenn alle anfangen zu rennen und sich gegenseitig anstoßen, wird die Menge zu einem chaotischen Durcheinander. Das ist <strong>turbulente Strömung</strong>, voller Wirbel und Strudel. Sie ist viel energiereicher und unvorhersehbarer.</p><h4>Das Reynolds-Experiment</h4><p>Ein Wissenschaftler namens Osborne Reynolds führte ein berühmtes Experiment durch, um dies zu zeigen. Er injizierte einen dünnen Farbstrahl in Wasser, das in einem Glasrohr floss. Bei niedrigen Geschwindigkeiten war der Farbstoff eine perfekte, gerade Linie (laminar). Als er die Geschwindigkeit erhöhte, wackelte die Linie und zerplatzte dann in komplexe Muster (turbulent). In diesem Spiel kannst du seine Entdeckung nachstellen!</p><h4>Von Flussbiegungen zu geraden Kanälen</h4><p>Die Mandau in Zittau war früher sehr kurvenreich. Obwohl schön, kann dies Probleme wie das Abtragen von Flussufern (Erosion) verursachen. Um die Stadt zu schützen, begradigten Ingenieure Teile des Flusses. In den späteren Herausforderungen wirst du zum Ingenieur! Du baust Kanäle, um das Wasser effizient zu leiten, genau wie in der realen Welt.</p>", advancedTitle: "Fortgeschrittene Strömungsdynamik", advancedText: "<p>Die Bewegung von Flüssigkeiten wird durch die <strong>Navier-Stokes-Gleichungen</strong> beschrieben, eine Reihe komplexer Differentialgleichungen. Sie berücksichtigen Kräfte wie Druck, Viskosität (die innere Reibung der Flüssigkeit) und Trägheit (die Tendenz der Flüssigkeit, in Bewegung zu bleiben).</p><h4>Die Reynolds-Zahl (Re)</h4><p>Osborne Reynolds quantifizierte den Übergang von laminarer zu turbulenter Strömung mit einer dimensionslosen Größe, der <strong>Reynolds-Zahl (Re)</strong>. Sie ist das Verhältnis von Trägheitskräften zu viskosen Kräften in einer Flüssigkeit.</p><p><code>Re = (ρuL) / μ</code>, wobei ρ die Dichte, u die Geschwindigkeit, L eine charakteristische Länge und μ die dynamische Viskosität ist.</p><p>Eine niedrige Re zeigt an, dass viskose Kräfte dominant sind, was zu einer glatten, <strong>laminaren Strömung</strong> führt. Eine hohe Re zeigt an, dass Trägheitskräfte dominieren, was zu einer chaotischen, <strong>turbulenten Strömung</strong> führt. In diesem Spiel erhöht das Erhöhen der Strömungsgeschwindigkeit direkt die Reynolds-Zahl.</p><h4>Wasserbau und die Mandau</h4><p>Die Begradigung der Mandau ist ein klassisches Beispiel für Wasserbau. Ein mäandrierender Fluss hat einen langen Weg, was bei Hochwasser für den Abtransport großer Wassermengen ineffizient sein kann. Durch die Schaffung eines direkten, künstlichen Kanals wird die Strömungsgeschwindigkeit effektiver gesteuert, was das Hochwasserrisiko und die Ufererosion verringert. Die Herausforderungen, bei denen du Kanäle baust, um das Durchflussverhältnis zu maximieren, sind ein vereinfachtes Modell dieses realen Problems: das Entwerfen eines Systems zur Optimierung des Flüssigkeitstransports.</p>" },
                introModal: { title: "Willkommen zur Reynolds-Herausforderung!", desc1: "Dein Ziel ist es, Turbulenzen zu erzeugen, indem du die Geschwindigkeit des Wassers erhöhst. Benutze den 'Fluss erhöhen'-Knopf, um das Wasser zu beschleunigen.", desc2: "Du hast <strong>10 Sekunden</strong> Zeit, eine Geschwindigkeit von <strong>200</strong> oder mehr zu erreichen.", startBtn: "Experiment starten" },
                velocityInfoModal: { title: "Beobachte die Turbulenz", desc: "Siehst du, wie der glatte Farbstrahl in Wirbel und Strudel zerfällt? Das ist <strong>Turbulenz</strong>! Du hast jetzt 5 Sekunden Zeit zum Beobachten.", nextBtn: "Nächste Lektion" },
                pressureIntroModal: { title: "Die Rolle des Drucks", desc1: "Bei Turbulenzen geht es nicht nur um Geschwindigkeit; sie werden durch chaotische Druckänderungen angetrieben. Hochdruckzonen drücken Flüssigkeit in Niederdruckzonen und erzeugen so die Wirbel, die du gesehen hast.", desc2: "Deine nächste Aufgabe: Stelle die turbulente Strömung aus dem Gedächtnis wieder her. Setze die Geschwindigkeit auf <strong style='font-size: 1.2rem;'><span id='target-velocity-display'></span></strong> zurück und drücke 'Senden'.", startBtn: "Druck-Herausforderung starten" },
                pressureInfoModal: { title: "Der 'Motor' der Turbulenz", desc: "Du siehst jetzt das <strong>Druckfeld</strong>. Rote Bereiche haben hohen Druck, blaue Bereiche haben niedrigen Druck.", desc2: "Stell es dir wie Hügel und Täler vor. Wasser strömt von den Hochdruck-'Hügeln' zu den Niederdruck-'Tälern'. In einer turbulenten Strömung entstehen und verschwinden diese Hügel und Täler chaotisch und erzeugen die wirbelnden Strudel, die du mit der Farbe gesehen hast. Dieser ständige, instabile Druckunterschied ist der wahre Motor der Turbulenz.", desc3: "Gut gemacht! Beobachte dies für 5 Sekunden vor der letzten Herausforderung.", nextBtn: "Letzte Herausforderung" },
                failModal: { title: "Herausforderung gescheitert", velocityDesc: "Du hast die Geschwindigkeit in 10 Sekunden nicht genug erhöht, um starke Turbulenzen zu erzeugen! Eine Geschwindigkeit von 200 oder mehr ist erforderlich.", pressureDesc: "Du hast die Zielgeschwindigkeit nicht genau genug getroffen. Das Ziel ist, ein intuitives Gefühl für die Geschwindigkeit und das Aussehen der Strömung zu entwickeln.", yourVelocity: "Deine Geschwindigkeit:", target: "Ziel:", tryAgainBtn: "Erneut versuchen" },
                obstacleFailModal: { title: "Kanal blockiert!", desc: "Es scheint, als ob dein Kanal den Ein- oder Auslass blockiert und den Wasserfluss verhindert. Für ein erfolgreiches Design ist ein offener Weg erforderlich!", tryAgainBtn: "Erneut bauen" },
                obstacleModals: { title3: "Herausforderung 3: Baue ein Flussufer", desc3: "Benutze deinen Cursor, um die Kanalwände zu zeichnen. Deine Aufgabe ist es, einen effizienten Kanal zu bauen, um das Wasser vom <strong style='color: var(--cyan-300)'>Einlass links</strong> zum <strong style='color: var(--green-400)'>Auslass unten</strong> zu leiten. Ziele auf das höchstmögliche Durchflussverhältnis (eine höhere Zahl ist besser)!", startBtn: "Bauen beginnen", title4: "Herausforderung 4: Teile die Strömung", desc4: "Benutze deinen Cursor, um die Kanalwände zu zeichnen. Baue nun einen Kanal, der die Strömung vom <strong style='color: var(--cyan-300)'>Einlass</strong> zu den <strong style='color: var(--green-400)'>Auslässen oben und unten</strong> aufteilt. Maximiere das kombinierte Durchflussverhältnis!", title5: "Letzte Herausforderung: Dreifache Bedrohung", desc5: "Benutze deinen Cursor, um die Kanalwände zu zeichnen. Der ultimative Test: Leite das Wasser vom <strong style='color: var(--cyan-300)'>Einlass</strong> zu drei <strong style='color: var(--green-400)'>Auslässen (oben, unten und rechts)</strong>. Entwerfe das effizienteste System, um das Durchflussverhältnis zu maximieren." },
                winModal: { levelComplete: "Level abgeschlossen!", flowRatio: "Dein Durchflussverhältnis:", nextLevelBtn: "Nächstes Level", retryBtn: "Erneut versuchen", congrats: "Herzlichen Glückwunsch!", totalTime: "Gesamtzeit:", finalFlowRatio: "Endgültiges Durchflussverhältnis:", playAgainBtn: "Erneut spielen" },
                mainControls: { decreaseFlow: "Fluss verringern", increaseFlow: "Fluss erhöhen", pause: "Pause", play: "Start", showPressure: "Druck zeigen", showDye: "Farbe zeigen", submitVelocity: "Geschwindigkeit senden" },
                buildControls: { buildChannel: "Kanal bauen", stopBuilding: "Bauen stoppen", clearObstacles: "Hindernisse entfernen", goWithFlow: "Los geht's!" },
                info: { peakFlow: "Spitzenfluss:", flowCharacter: "Strömungsart:", stable: "Stabil", unstable: "Instabil", chaotic: "Chaotisch" },
                canvasLabels: { inlet: 'EINLASS', outlet: 'AUSLASS' },
                legend: { highPressure: "Hoher Druck", lowPressure: "Niedriger Druck" }
            },
            pl: {
                welcomeModal: { title: "Wyzwanie Reynoldsa w Zittau", desc: "Interaktywna gra o dynamice płynów, inspirowana rzeką Mandau.", startBtn: "Rozpocznij grę", learnBtn: "Dowiedz się, jak płynie woda", rankingBtn: "Ranking" },
                learnModal: { title: "Dowiedz się, jak płynie woda", desc: "Wybierz poziom szczegółowości, aby dowiedzieć się o fizyce płynów.", beginnerBtn: "Początkujący", advancedBtn: "Zaawansowany", backBtn: "Wróć", beginnerTitle: "Przewodnik dla początkujących po przepływie wody", beginnerText: "<p>Wyobraź sobie, że woda jest jak tłum ludzi. Kiedy idą powoli, wszyscy poruszają się w schludnych, uporządkowanych rzędach. Nazywa się to <strong>przepływem laminarnym</strong>. Jest gładki i przewidywalny.</p><p>Ale jeśli wszyscy zaczną biec i wpadać na siebie, tłum stanie się chaotycznym bałaganem. To jest <strong>przepływ turbulentny</strong>, pełen wirów. Jest znacznie bardziej energiczny i nieprzewidywalny.</p><h4>Eksperyment Reynoldsa</h4><p>Naukowiec o nazwisku Osborne Reynolds przeprowadził słynny eksperyment, aby to pokazać. Wstrzyknął cienki strumień barwnika do wody płynącej w szklanej rurze. Przy niskich prędkościach barwnik tworzył idealną, prostą linię (laminarny). Gdy zwiększał prędkość, linia zaczęła się chwiać, a następnie rozpadła się na złożone wzory (turbulentny). Ta gra pozwala odtworzyć jego odkrycie!</p><h4>Od zakrętów rzeki do prostych kanałów</h4><p>Rzeka Mandau w Zittau była kiedyś bardzo kręta. Chociaż ładne, może to powodować problemy, takie jak niszczenie brzegów rzeki (erozja). Aby chronić miasto, inżynierowie wyprostowali części rzeki. W późniejszych wyzwaniach zostaniesz inżynierem! Będziesz budować kanały, aby sprawnie kierować wodą, tak jak robiono to w prawdziwym świecie.</p>", advancedTitle: "Zaawansowana dynamika płynów", advancedText: "<p>Ruch płynów jest opisywany przez <strong>równania Naviera-Stokesa</strong>, zestaw złożonych równań różniczkowych. Uwzględniają one siły takie jak ciśnienie, lepkość (wewnętrzne tarcie płynu) i bezwładność (tendencja płynu do utrzymywania ruchu).</p><h4>Liczba Reynoldsa (Re)</h4><p>Osborne Reynolds określił ilościowo przejście od przepływu laminarnego do turbulentnego za pomocą bezwymiarowej wielkości, <strong>liczby Reynoldsa (Re)</strong>. Jest to stosunek sił bezwładności do sił lepkości w płynie.</p><p><code>Re = (ρuL) / μ</code>, gdzie ρ to gęstość, u to prędkość, L to charakterystyczna długość, a μ to lepkość dynamiczna.</p><p>Niska liczba Re wskazuje, że dominują siły lepkości, co skutkuje gładkim, <strong>przepływem laminarnym</strong>. Wysoka liczba Re wskazuje, że dominują siły bezwładności, co prowadzi do chaotycznego, <strong>przepływu turbulentnego</strong>. W tej grze zwiększenie prędkości przepływu bezpośrednio podnosi liczbę Reynoldsa.</p><h4>Inżynieria hydrauliczna a Mandau</h4><p>Prostowanie rzeki Mandau to klasyczny przykład inżynierii hydraulicznej. Meandrująca rzeka ma długą drogę, co może być nieefektywne przy przemieszczaniu dużych objętości wody podczas powodzi. Tworząc bezpośredni, zaprojektowany kanał, prędkość przepływu jest zarządzana bardziej efektywnie, co zmniejsza ryzyko powodzi i erozji brzegów. Wyzwania, w których budujesz kanały, aby zmaksymalizować stosunek przepływu, są uproszczonym modelem tego rzeczywistego problemu: projektowania systemu w celu optymalizacji transportu płynów.</p>" },
                introModal: { title: "Witaj w Wyzwaniu Reynoldsa!", desc1: "Twoim celem jest stworzenie turbulencji poprzez zwiększenie prędkości wody. Użyj przycisku 'Zwiększ przepływ', aby przyspieszyć wodę.", desc2: "Masz <strong>10 sekund</strong>, aby osiągnąć prędkość <strong>200</strong> lub więcej.", startBtn: "Rozpocznij eksperyment" },
                velocityInfoModal: { title: "Obserwuj turbulencje", desc: "Zauważ, jak gładki strumień barwnika rozpadł się na wiry? To <strong>turbulencja</strong>! Masz teraz 5 sekund na obserwację.", nextBtn: "Następna lekcja" },
                pressureIntroModal: { title: "Rola ciśnienia", desc1: "Turbulencja to nie tylko prędkość; jest napędzana chaotycznymi zmianami ciśnienia. Strefy wysokiego ciśnienia pchają płyn do stref niskiego ciśnienia, tworząc wiry, które widziałeś.", desc2: "Twoje następne zadanie: Odtwórz przepływ turbulentny z pamięci. Ustaw prędkość z powrotem na <strong style='font-size: 1.2rem;'><span id='target-velocity-display'></span></strong> i naciśnij 'Zatwierdź'.", startBtn: "Rozpocznij wyzwanie ciśnieniowe" },
                pressureInfoModal: { title: "'Silnik' turbulencji", desc: "Teraz widzisz <strong>pole ciśnienia</strong>. Czerwone obszary mają wysokie ciśnienie, a niebieskie niskie ciśnienie.", desc2: "Pomyśl o tym jak o wzgórzach i dolinach. Woda pędzi z 'wzgórz' wysokiego ciśnienia do 'dolin' niskiego ciśnienia. W przepływie turbulentnym te wzgórza i doliny tworzą się i znikają chaotycznie, tworząc wirujące prądy, które widziałeś z barwnikiem. Ta stała, niestabilna różnica ciśnień jest prawdziwym silnikiem napędzającym turbulencje.", desc3: "Dobra robota! Obserwuj to przez 5 sekund przed ostatnim wyzwaniem.", nextBtn: "Ostatnie wyzwanie" },
                failModal: { title: "Wyzwanie nieudane", velocityDesc: "Nie zwiększyłeś prędkości wystarczająco w 10 sekund, aby stworzyć silną turbulencję! Wymagana jest prędkość 200 lub więcej.", pressureDesc: "Nie dopasowałeś docelowej prędkości wystarczająco dokładnie. Celem jest rozwinięcie intuicyjnego wyczucia prędkości i wyglądu przepływu.", yourVelocity: "Twoja prędkość:", target: "Cel:", tryAgainBtn: "Spróbuj ponownie" },
                obstacleFailModal: { title: "Kanał zablokowany!", desc: "Wygląda na to, że twój kanał blokuje wlot lub wylot, uniemożliwiając przepływ wody. Otwarta ścieżka jest potrzebna do udanego projektu!", tryAgainBtn: "Spróbuj zbudować ponownie" },
                obstacleModals: { title3: "Wyzwanie 3: Zbuduj brzeg rzeki", desc3: "Użyj kursora, aby narysować ściany kanału. Twoim zadaniem jest zbudowanie wydajnego kanału do prowadzenia wody od <strong style='color: var(--cyan-300)'>wlotu po lewej stronie</strong> do <strong style='color: var(--green-400)'>wylotu na dole</strong>. Dąż do jak najwyższego stosunku przepływu (wyższa liczba jest lepsza)!", startBtn: "Rozpocznij budowę", title4: "Wyzwanie 4: Podziel przepływ", desc4: "Użyj kursora, aby narysować ściany kanału. Teraz zbuduj kanał, który dzieli przepływ od <strong style='color: var(--cyan-300)'>wlotu</strong> do <strong style='color: var(--green-400)'>wylotów na górze i na dole</strong>. Zmaksymalizuj połączony stosunek przepływu!", title5: "Ostatnie wyzwanie: Potrójne zagrożenie", desc5: "Użyj kursora, aby narysować ściany kanału. Ostateczny test: Skieruj wodę od <strong style='color: var(--cyan-300)'>wlotu</strong> do trzech <strong style='color: var(--green-400)'>wylotów (góra, dół i prawo)</strong>. Zaprojektuj najbardziej wydajny system, aby zmaksymalizować stosunek przepływu." },
                winModal: { levelComplete: "Poziom ukończony!", flowRatio: "Twój stosunek przepływu:", nextLevelBtn: "Następny poziom", retryBtn: "Spróbuj ponownie", congrats: "Gratulacje!", totalTime: "Całkowity czas:", finalFlowRatio: "Końcowy stosunek przepływu:", playAgainBtn: "Zagraj ponownie" },
                mainControls: { decreaseFlow: "Zmniejsz przepływ", increaseFlow: "Zwiększ przepływ", pause: "Pauza", play: "Wznów", showPressure: "Pokaż ciśnienie", showDye: "Pokaż barwnik", submitVelocity: "Zatwierdź prędkość" },
                buildControls: { buildChannel: "Buduj kanał", stopBuilding: "Zatrzymaj budowę", clearObstacles: "Wyczyść przeszkody", goWithFlow: "Płyń z prądem!" },
                info: { peakFlow: "Szczytowy przepływ:", flowCharacter: "Charakter przepływu:", stable: "Stabilny", unstable: "Niestabilny", chaotic: "Chaotyczny" },
                canvasLabels: { inlet: 'WLOT', outlet: 'WYLOT' },
                legend: { highPressure: "Wysokie ciśnienie", lowPressure: "Niskie ciśnienie" }
            },
            cz: {
                welcomeModal: { title: "Reynoldsova výzva v Žitavě", desc: "Interaktivní hra o dynamice kapalin, inspirovaná řekou Mandavou.", startBtn: "Spustit hru", learnBtn: "Jak teče voda", rankingBtn: "Žebříček" },
                learnModal: { title: "Jak teče voda", desc: "Zvolte úroveň podrobností, abyste se dozvěděli o fyzice kapalin.", beginnerBtn: "Začátečník", advancedBtn: "Pokročilý", backBtn: "Zpět", beginnerTitle: "Průvodce prouděním vody pro začátečníky", beginnerText: "<p>Představte si, že voda je jako dav lidí. Když jdou pomalu, všichni se pohybují v úhledných, uspořádaných řadách. Tomu se říká <strong>laminární proudění</strong>. Je hladké a předvídatelné.</p><p>Ale pokud všichni začnou běžet a narážet do sebe, dav se stane chaotickým zmatkem. To je <strong>turbulentní proudění</strong>, plné vírů. Je mnohem energičtější a nepředvídatelnější.</p><h4>Reynoldsův experiment</h4><p>Vědec jménem Osborne Reynolds provedl slavný experiment, aby to ukázal. Vstříkl tenký proud barviva do vody proudící ve skleněné trubici. Při nízkých rychlostech bylo barvivo dokonalou, rovnou čarou (laminární). Jak zvyšoval rychlost, čára se začala vlnit a pak se rozpadla na složité vzory (turbulentní). Tato hra vám umožní znovu objevit jeho objev!</p><h4>Od zákrutů řeky k rovným kanálům</h4><p>Řeka Mandava v Žitavě bývala velmi klikatá. I když je to hezké, může to způsobit problémy, jako je odplavování břehů řeky (eroze). Aby město ochránili, inženýři části řeky narovnali. V pozdějších výzvách se stanete inženýrem! Budete stavět kanály, abyste efektivně vedli vodu, přesně jako to dělali ve skutečném světě.</p>", advancedTitle: "Pokročilá dynamika kapalin", advancedText: "<p>Pohyb kapalin je popsán <strong>Navier-Stokesovými rovnicemi</strong>, souborem složitých diferenciálních rovnic. Zohledňují síly jako tlak, viskozitu (vnitřní tření kapaliny) a setrvačnost (tendence kapaliny pokračovat v pohybu).</p><h4>Reynoldsovo číslo (Re)</h4><p>Osborne Reynolds kvantifikoval přechod z laminárního na turbulentní proudění pomocí bezrozměrné veličiny, <strong>Reynoldsova čísla (Re)</strong>. Je to poměr setrvačných sil k viskózním silám v kapalině.</p><p><code>Re = (ρuL) / μ</code>, kde ρ je hustota, u je rychlost, L je charakteristická délka a μ je dynamická viskozita.</p><p>Nízké Re naznačuje, že dominují viskózní síly, což vede k hladkému, <strong>laminárnímu proudění</strong>. Vysoké Re naznačuje, že dominují setrvačné síly, což vede k chaotickému, <strong>turbulentnímu proudění</strong>. V této hře zvýšení rychlosti proudění přímo zvyšuje Reynoldsovo číslo.</p><h4>Hydraulické inženýrství a Mandava</h4><p>Narovnání řeky Mandavy je klasickým příkladem hydraulického inženýrství. Meandrující řeka má dlouhou cestu, což může být neefektivní pro pohyb velkých objemů vody během povodní. Vytvořením přímého, inženýrského kanálu je rychlost proudění řízena efektivněji, což snižuje riziko povodní a eroze břehů. Výzvy, ve kterých stavíte kanály pro maximalizaci poměru průtoku, jsou zjednodušeným modelem tohoto reálného problému: navrhování systému pro optimalizaci transportu kapalin.</p>" },
                introModal: { title: "Vítejte v Reynoldsově výzvě!", desc1: "Vaším cílem je vytvořit turbulenci zvýšením rychlosti vody. Použijte tlačítko 'Zvýšit průtok' k zrychlení vody.", desc2: "Máte <strong>10 sekund</strong> na dosažení rychlosti <strong>200</strong> nebo více.", startBtn: "Spustit experiment" },
                velocityInfoModal: { title: "Pozorujte turbulenci", desc: "Všimněte si, jak se hladký proud barviva rozpadl na víry? To je <strong>turbulence</strong>! Nyní máte 5 sekund na pozorování.", nextBtn: "Další lekce" },
                pressureIntroModal: { title: "Role tlaku", desc1: "Turbulence není jen o rychlosti; je poháněna chaotickými změnami tlaku. Zóny vysokého tlaku tlačí kapalinu do zón nízkého tlaku, čímž vytvářejí víry, které jste viděli.", desc2: "Váš další úkol: Znovu vytvořte turbulentní proudění z paměti. Nastavte rychlost zpět na <strong style='font-size: 1.2rem;'><span id='target-velocity-display'></span></strong> a stiskněte 'Odeslat'.", startBtn: "Spustit tlakovou výzvu" },
                pressureInfoModal: { title: "'Motor' turbulence", desc: "Nyní vidíte <strong>tlakové pole</strong>. Červené oblasti mají vysoký tlak a modré oblasti nízký tlak.", desc2: "Představte si to jako kopce a údolí. Voda se řítí z vysokotlakých 'kopců' do nízkotlakých 'údolí'. V turbulentním proudění se tyto kopce a údolí chaoticky tvoří a mizí, čímž vytvářejí vířící proudy, které jste viděli s barvivem. Tento neustálý, nestabilní tlakový rozdíl je skutečným motorem pohánějícím turbulenci.", desc3: "Výborně! Pozorujte to po dobu 5 sekund před finální výzvou.", nextBtn: "Finální výzva" },
                failModal: { title: "Výzva neúspěšná", velocityDesc: "Nezvýšili jste rychlost dostatečně za 10 sekund, abyste vytvořili silnou turbulenci! Je vyžadována rychlost 200 nebo více.", pressureDesc: "Nedosáhli jste cílové rychlosti dostatečně přesně. Cílem je vyvinout intuitivní cit pro rychlost a vzhled proudění.", yourVelocity: "Vaše rychlost:", target: "Cíl:", tryAgainBtn: "Zkusit znovu" },
                obstacleFailModal: { title: "Kanál zablokován!", desc: "Zdá se, že váš kanál blokuje vtok nebo výtok a brání průtoku vody. Pro úspěšný návrh je nutná otevřená cesta!", tryAgainBtn: "Zkusit stavět znovu" },
                obstacleModals: { title3: "Výzva 3: Postavte břeh řeky", desc3: "Pomocí kurzoru nakreslete stěny kanálu. Vaším úkolem je postavit efektivní kanál pro vedení vody od <strong style='color: var(--cyan-300)'>vtoku vlevo</strong> k <strong style='color: var(--green-400)'>výtoku dole</strong>. Cílem je dosáhnout co nejvyššího poměru průtoku (vyšší číslo je lepší)!", startBtn: "Začít stavět", title4: "Výzva 4: Rozdělte proud", desc4: "Pomocí kurzoru nakreslete stěny kanálu. Nyní postavte kanál, který rozděluje proud od <strong style='color: var(--cyan-300)'>vtoku</strong> k <strong style='color: var(--green-400)'>výtokům nahoře i dole</strong>. Maximalizujte kombinovaný poměr průtoku!", title5: "Finální výzva: Trojitá hrozba", desc5: "Pomocí kurzoru nakreslete stěny kanálu. Ultimátní test: Nasměrujte vodu od <strong style='color: var(--cyan-300)'>vtoku</strong> ke třem <strong style='color: var(--green-400)'>výtokům (nahoře, dole a vpravo)</strong>. Navrhněte nejúčinnější systém pro maximalizaci poměru průtoku." },
                winModal: { levelComplete: "Úroveň dokončena!", flowRatio: "Váš poměr průtoku:", nextLevelBtn: "Další úroveň", retryBtn: "Zkusit znovu", congrats: "Gratulujeme!", totalTime: "Celkový čas:", finalFlowRatio: "Konečný poměr průtoku:", playAgainBtn: "Hrát znovu" },
                mainControls: { decreaseFlow: "Snížit průtok", increaseFlow: "Zvýšit průtok", pause: "Pauza", play: "Spustit", showPressure: "Zobrazit tlak", showDye: "Zobrazit barvivo", submitVelocity: "Odeslat rychlost" },
                buildControls: { buildChannel: "Stavět kanál", stopBuilding: "Zastavit stavbu", clearObstacles: "Odstranit překážky", goWithFlow: "Do toho!" },
                info: { peakFlow: "Špičkový průtok:", flowCharacter: "Charakter proudění:", stable: "Stabilní", unstable: "Nestabilní", chaotic: "Chaotické" },
                canvasLabels: { inlet: 'VTOK', outlet: 'VÝTOK' },
                legend: { highPressure: "Vysoký tlak", lowPressure: "Nízký tlak" }
            }
        };

        // --- DOM Elements ---
        const welcomeScreen = document.getElementById('welcome-screen');
        const gameView = document.getElementById('game-view');
        const canvas = document.getElementById('fluid-canvas');
        const infoDiv = document.getElementById('info');
        const ctx = canvas.getContext('2d');
        const container = document.querySelector('.canvas-container');
        const decreaseBtn = document.getElementById('decrease-flow');
        const increaseBtn = document.getElementById('increase-flow');
        const pauseBtn = document.getElementById('pause-sim');
        const pressureBtn = document.getElementById('toggle-pressure');
        const submitVelocityBtn = document.getElementById('submit-velocity-btn');
        const timerDiv = document.getElementById('timer');
        const canalDiv = document.getElementById('canal-div');
        const outflowDiv = document.getElementById('outflow-div');
        const mainControls = document.getElementById('main-controls');
        const buildControls = document.getElementById('build-controls');
        const buildChannelBtn = document.getElementById('build-channel-btn');
        const clearObstaclesBtn = document.getElementById('clear-obstacles-btn');
        const flowBtn = document.getElementById('flow-btn');
        const pressureLegend = document.getElementById('pressure-legend');
        // Modals
        const modals = {
            learn: document.getElementById('learn-modal'),
            intro: document.getElementById('intro-modal'),
            infoVelocity: document.getElementById('info-popup-velocity'),
            pressureIntro: document.getElementById('pressure-intro-modal'),
            infoPressure: document.getElementById('info-popup-pressure'),
            failVelocity: document.getElementById('fail-modal'),
            failPressure: document.getElementById('fail-modal-pressure'),
            obstacleFail: document.getElementById('obstacle-fail-modal'),
            obstacleIntro3: document.getElementById('obstacle-intro-modal-3'),
            obstacleIntro4: document.getElementById('obstacle-intro-modal-4'),
            obstacleIntro5: document.getElementById('obstacle-intro-modal-5'),
            levelWin: document.getElementById('level-win-modal'),
            win: document.getElementById('win-modal')
        };
        // Welcome/Learn Screen Buttons
        document.getElementById('start-game-btn').addEventListener('click', () => { game.state = 'INTRO_VELOCITY'; updateUIForState(); });
        document.getElementById('learn-btn').addEventListener('click', () => { game.state = 'LEARN'; updateUIForState(); });
        document.getElementById('ranking-btn').addEventListener('click', () => alert('Ranking is coming soon!'));
        document.getElementById('learn-beginner-btn').addEventListener('click', () => showLearnContent('beginner'));
        document.getElementById('learn-advanced-btn').addEventListener('click', () => showLearnContent('advanced'));
        document.getElementById('learn-back-btn').addEventListener('click', () => { game.state = 'WELCOME'; updateUIForState(); });
        
        // Modal Buttons
        document.getElementById('start-btn').addEventListener('click', () => { game.state = 'CHALLENGE_VELOCITY'; updateUIForState(); });
        document.getElementById('close-velocity-popup-btn').addEventListener('click', handleCloseVelocityPopup);
        document.getElementById('start-pressure-challenge-btn').addEventListener('click', handleStartPressureChallenge);
        document.getElementById('close-pressure-popup-btn').addEventListener('click', handleClosePressurePopup);
        const startBuilding = () => { 
            game.state = 'BUILD_OBSTACLE'; 
            updateUIForState(); 
            requestAnimationFrame(() => setupScene(game.level)); 
        };
        document.getElementById('start-building-3-btn').addEventListener('click', startBuilding);
        document.getElementById('start-building-4-btn').addEventListener('click', startBuilding);
        document.getElementById('start-building-5-btn').addEventListener('click', startBuilding);
        document.getElementById('next-level-btn').addEventListener('click', () => { game.level++; game.state = 'INTRO_OBSTACLE'; updateUIForState(); });
        document.getElementById('retry-level-btn').addEventListener('click', () => { game.state = 'INTRO_OBSTACLE'; updateUIForState(); });
        document.getElementById('try-again-btn').addEventListener('click', () => { scene.flowVelocity = 5.0; setupScene(1); game.state = 'INTRO_VELOCITY'; updateUIForState(); });
        document.getElementById('try-again-pressure-btn').addEventListener('click', resetPressureChallenge);
        document.getElementById('try-again-obstacle-btn').addEventListener('click', () => { game.state = 'INTRO_OBSTACLE'; updateUIForState(); });
        document.getElementById('play-again-btn').addEventListener('click', resetGame);
        
        // Build Controls
        function toggleBuildMode() {
            game.buildModeActive = !game.buildModeActive;
            buildChannelBtn.classList.toggle('active', game.buildModeActive);
            buildChannelBtn.textContent = game.buildModeActive ? t('buildControls.stopBuilding') : t('buildControls.buildChannel');
        }

        buildChannelBtn.addEventListener('click', toggleBuildMode);

        clearObstaclesBtn.addEventListener('click', () => {
            setupScene(game.level);
            if (game.buildModeActive) {
                toggleBuildMode();
            }
        });

        flowBtn.addEventListener('click', () => {
            scene.showPressure = false; // Default to dye view for obstacle challenges
            scene.flowVelocity = (game.targetVelocity || 100.0) + 100.0;
            if (game.buildModeActive) {
                toggleBuildMode();
            }
            game.state = 'SIMULATE_OBSTACLE';
            startObstacleTimer();
            updateUIForState();
        });


        // --- Fluid Simulation Class ---
        class Fluid {
            constructor(density, numX, numY, h) {
                this.density = density;
                this.h = h;
                this.numX = numX + 2;
                this.numY = numY + 2;
                const size = this.numX * this.numY;
                this.u = new Float32Array(size); this.v = new Float32Array(size);
                this.p = new Float32Array(size); this.s = new Float32Array(size);
                this.m = new Float32Array(size).fill(1.0);
                this.inletMinJ = 0; this.inletMaxJ = 0;
                this.outlets = [];
            }
            _idx(i, j) { return i * this.numY + j; }
            simulate(dt, numIters, overRelaxation, flowVelocity, viscosity) {
                if (this.inletMaxJ > this.inletMinJ) {
                    const inletCenterJ = (this.inletMinJ + this.inletMaxJ) / 2.0;
                    const inletHalfWidth = (this.inletMaxJ - this.inletMinJ) / 2.0;
                    for (let j = this.inletMinJ; j < this.inletMaxJ; j++) {
                        const relativePos = (j - inletCenterJ) / inletHalfWidth;
                        const speed = flowVelocity * (1 - relativePos * relativePos);
                        this.u[this._idx(1, j)] = Math.max(0.0, speed);
                    }
                    for (let j = this.inletMinJ; j < this.inletMaxJ; j++) { this.m[this._idx(1, j)] = 0.0; }
                }

                // Advect velocity and smoke
                advectVel(this, dt);
                advectSmoke(this, dt);
                
                // Diffuse (viscosity)
                if (viscosity > 0) {
                    const u_0 = new Float32Array(this.u);
                    const v_0 = new Float32Array(this.v);
                    const diffuseIters = 4;
                    diffuse(this, dt, viscosity, diffuseIters, this.u, u_0);
                    diffuse(this, dt, viscosity, diffuseIters, this.v, v_0);
                }

                // Project to enforce incompressibility
                this.p.fill(0.0);
                solveIncompressibility(this, numIters, overRelaxation, dt);
                
                // Set boundary conditions
                extrapolate(this);
            }
        }

        // --- Physics Functions ---
        function solveIncompressibility(f, numIters, overRelaxation, dt) { 
            const cp = f.density * f.h / dt; 
            for (let iter = 0; iter < numIters; iter++) { 
                for (let i = 1; i < f.numX - 1; i++) { 
                    for (let j = 1; j < f.numY - 1; j++) { 
                        if (f.s[f._idx(i, j)] === 0.0) continue; 
                        let sSum = f.s[f._idx(i - 1, j)] + f.s[f._idx(i + 1, j)] + f.s[f._idx(i, j - 1)] + f.s[f._idx(i, j + 1)]; 
                        if (sSum === 0.0) continue; 
                        let div = f.u[f._idx(i + 1, j)] - f.u[f._idx(i, j)] + f.v[f._idx(i, j + 1)] - f.v[f._idx(i, j)]; 
                        let p = -div / sSum * overRelaxation; f.p[f._idx(i, j)] += cp * p; 
                        f.u[f._idx(i, j)] -= f.s[f._idx(i - 1, j)] * p; 
                        f.u[f._idx(i + 1, j)] += f.s[f._idx(i + 1, j)] * p; 
                        f.v[f._idx(i, j)] -= f.s[f._idx(i, j - 1)] * p; 
                        f.v[f._idx(i, j + 1)] += f.s[f._idx(i, j + 1)] * p; 
                    } 
                } 
                if (f.outlets) {
                    for (const outlet of f.outlets) {
                        if (outlet.wall === 'bottom') {
                            for (let i = outlet.min; i < outlet.max; i++) { f.p[f._idx(i, f.numY - 2)] = f.p[f._idx(i, f.numY - 3)]; }
                        }
                        if (outlet.wall === 'top') {
                            for (let i = outlet.min; i < outlet.max; i++) { f.p[f._idx(i, 1)] = f.p[f._idx(i, 2)]; }
                        }
                        if (outlet.wall === 'right') {
                            for (let j = outlet.min; j < outlet.max; j++) { f.p[f._idx(f.numX - 2, j)] = f.p[f._idx(f.numX - 3, j)]; }
                        }
                    }
                }
            } 
        }
        function extrapolate(f) { for (let i = 0; i < f.numX; i++) { f.u[f._idx(i, 0)] = f.u[f._idx(i, 1)]; f.u[f._idx(i, f.numY - 1)] = f.u[f._idx(i, f.numY - 2)]; } for (let j = 0; j < f.numY; j++) { f.v[f._idx(0, j)] = f.v[f._idx(1, j)]; f.v[f._idx(f.numX - 1, j)] = f.v[f._idx(f.numX - 2, j)]; } }
        function sampleField(f, x, y, fieldType, fieldData) { const h1 = 1.0 / f.h; const h2 = 0.5 * f.h; x = Math.max(Math.min(x, f.numX * f.h), f.h); y = Math.max(Math.min(y, f.numY * f.h), f.h); let dx = 0.0, dy = 0.0; if (fieldType === U_FIELD) dy = h2; else if (fieldType === V_FIELD) dx = h2; else if (fieldType === S_FIELD) { dx = h2; dy = h2; } const x0 = Math.min(Math.floor((x - dx) * h1), f.numX - 2); const tx = ((x - dx) - x0 * f.h) * h1; const x1 = Math.min(x0 + 1, f.numX - 2); const y0 = Math.min(Math.floor((y - dy) * h1), f.numY - 2); const ty = ((y - dy) - y0 * f.h) * h1; const y1 = Math.min(y0 + 1, f.numY - 2); const sx = 1.0 - tx; const sy = 1.0 - ty; return sx * sy * fieldData[f._idx(x0, y0)] + tx * sy * fieldData[f._idx(x1, y0)] + tx * ty * fieldData[f._idx(x1, y1)] + sx * ty * fieldData[f._idx(x0, y1)]; }
        function advectVel(f, dt) { const newU = new Float32Array(f.u); const newV = new Float32Array(f.v); const h2 = 0.5 * f.h; for (let i = 1; i < f.numX - 1; i++) { for (let j = 1; j < f.numY - 1; j++) { if (f.s[f._idx(i, j)] !== 0.0 && f.s[f._idx(i - 1, j)] !== 0.0) { let px = i * f.h; let py = j * f.h + h2; const u = f.u[f._idx(i, j)]; const avgV = 0.25 * (f.v[f._idx(i - 1, j)] + f.v[f._idx(i, j)] + f.v[f._idx(i - 1, j + 1)] + f.v[f._idx(i, j + 1)]); px -= dt * u; py -= dt * avgV; newU[f._idx(i, j)] = sampleField(f, px, py, U_FIELD, f.u); } if (f.s[f._idx(i, j)] !== 0.0 && f.s[f._idx(i, j - 1)] !== 0.0) { let px = i * f.h + h2; let py = j * f.h; const avgU = 0.25 * (f.u[f._idx(i, j - 1)] + f.u[f._idx(i, j)] + f.u[f._idx(i + 1, j - 1)] + f.u[f._idx(i + 1, j)]); const v = f.v[f._idx(i, j)]; px -= dt * avgU; py -= dt * v; newV[f._idx(i, j)] = sampleField(f, px, py, V_FIELD, f.v); } } } f.u.set(newU); f.v.set(newV); }
        function advectSmoke(f, dt) { const newM = new Float32Array(f.m); const h2 = 0.5 * f.h; for (let i = 1; i < f.numX - 1; i++) { for (let j = 1; j < f.numY - 1; j++) { if (f.s[f._idx(i, j)] !== 0.0) { const avgU = (f.u[f._idx(i, j)] + f.u[f._idx(i + 1, j)]) * 0.5; const avgV = (f.v[f._idx(i, j)] + f.v[f._idx(i, j + 1)]) * 0.5; let x = i * f.h + h2 - dt * avgU; let y = j * f.h + h2 - dt * avgV; newM[f._idx(i, j)] = sampleField(f, x, y, S_FIELD, f.m); } } } f.m.set(newM); }

        function diffuse(f, dt, viscosity, numIters, field, field_0) {
            const h = f.h;
            const a = dt * viscosity / (h * h);
            
            for (let iter = 0; iter < numIters; iter++) {
                for (let i = 1; i < f.numX - 1; i++) {
                    for (let j = 1; j < f.numY - 1; j++) {
                        if (f.s[f._idx(i, j)] === 0.0) continue;
                        
                        const sumNeighbors = field[f._idx(i - 1, j)] + field[f._idx(i + 1, j)] +
                                             field[f._idx(i, j - 1)] + field[f._idx(i, j + 1)];

                        field[f._idx(i, j)] = (field_0[f._idx(i, j)] + a * sumNeighbors) / (1 + 4 * a);
                    }
                }
            }
        }

        // --- Scene and Game State ---
        const scene = { fluid: null, dt: 1.0 / 60.0, numIters: 40, overRelaxation: 1.9, paused: true, flowVelocity: 5.0, showPressure: false, viscosity: 1.0 };
        const game = {
            state: 'WELCOME', flowState: 'Stable', timerValue: 10, timerInterval: null,
            targetVelocity: 0, buildModeActive: false, totalGameStartTime: null,
            level: 1, obstacleTimerValue: 10, obstacleTimerInterval: null, language: 'en'
        };
        let offscreenCanvas, offscreenCtx, imageData;

        // Translation helper
        function t(key) {
            const keys = key.split('.');
            let result = translations[game.language];
            for (const k of keys) {
                if (result) result = result[k];
                else return key;
            }
            return result || key;
        }

        function updateTexts() {
            document.querySelectorAll('[data-t]').forEach(el => {
                const key = el.getAttribute('data-t');
                const translation = t(key);
                // Allow HTML in translations, but default to textContent for safety
                if (translation.includes('<')) {
                    el.innerHTML = translation;
                } else {
                    el.textContent = translation;
                }
            });
             // Also update dynamic texts that are not handled by data-t
            updateUIForState();
        }


        function setupScene(level = 1) {
            const rect = container.getBoundingClientRect(); if (rect.width === 0 || rect.height === 0) return;
            canvas.width = rect.width; canvas.height = rect.height;
            const simHeight = 1.0; const cScale = canvas.height / simHeight;
            const simWidth = canvas.width / cScale;
            const res = 120; const domainHeight = 100.0; const domainWidth = domainHeight / simHeight * simWidth;
            const h = domainHeight / res;
            const numX = Math.floor(domainWidth / h); const numY = Math.floor(domainHeight / h);
            const f = new Fluid(1000.0, numX, numY, h);
            scene.fluid = f;
            f.outlets = []; // Clear outlets from previous levels
            f.s.fill(0.0); // All solid by default
            for (let i = 1; i < f.numX - 1; i++) { for (let j = 1; j < f.numY - 1; j++) { f.s[f._idx(i, j)] = 1.0; } } // Fluid in the middle

            if (level <= 2) {
                const pipeH = 0.4 * f.numY;
                f.inletMinJ = Math.floor(0.5 * f.numY - 0.5 * pipeH); f.inletMaxJ = Math.floor(0.5 * f.numY + 0.5 * pipeH);
                for (let j = f.inletMinJ; j < f.inletMaxJ; j++) { f.s[f._idx(1, j)] = 1.0; } // Inlet
                for (let j = 1; j < f.numY - 1; j++) { f.s[f._idx(f.numX - 1, j)] = 1.0; } // Outlet
            } else { // Obstacle levels >= 3
                const pipeH = 0.2 * f.numY; 
                f.inletMinJ = Math.floor(0.5 * f.numY - 0.5 * pipeH); f.inletMaxJ = Math.floor(0.5 * f.numY + 0.5 * pipeH);
                const outletW = 0.2 * f.numX;
                const outletH = 0.2 * f.numY;
                if (level === 3) {
                    const outletMinI = Math.floor(0.5 * f.numX - 0.5 * outletW);
                    const outletMaxI = Math.floor(0.5 * f.numX + 0.5 * outletW);
                    f.outlets.push({ wall: 'bottom', min: outletMinI, max: outletMaxI });
                    for(let i = outletMinI; i < outletMaxI; i++) { f.s[f._idx(i, f.numY - 2)] = 1.0; }
                } else if (level === 4) {
                    const outletMinI = Math.floor(0.5 * f.numX - 0.5 * outletW);
                    const outletMaxI = Math.floor(0.5 * f.numX + 0.5 * outletW);
                    f.outlets.push({ wall: 'bottom', min: outletMinI, max: outletMaxI });
                    f.outlets.push({ wall: 'top', min: outletMinI, max: outletMaxI });
                    for(let i = outletMinI; i < outletMaxI; i++) { 
                        f.s[f._idx(i, f.numY - 2)] = 1.0; // bottom
                        f.s[f._idx(i, 1)] = 1.0; // top
                    }
                } else if (level === 5) {
                    const outletMinI_bt = Math.floor(0.5 * f.numX - 0.5 * outletW);
                    const outletMaxI_bt = Math.floor(0.5 * f.numX + 0.5 * outletW);
                    const outletMinJ_r = Math.floor(0.5 * f.numY - 0.5 * outletH);
                    const outletMaxJ_r = Math.floor(0.5 * f.numY + 0.5 * outletH);
                    f.outlets.push({ wall: 'bottom', min: outletMinI_bt, max: outletMaxI_bt });
                    f.outlets.push({ wall: 'top', min: outletMinI_bt, max: outletMaxI_bt });
                    f.outlets.push({ wall: 'right', min: outletMinJ_r, max: outletMaxJ_r });
                    for(let i = outletMinI_bt; i < outletMaxI_bt; i++) { 
                        f.s[f._idx(i, f.numY - 2)] = 1.0; // bottom
                        f.s[f._idx(i, 1)] = 1.0; // top
                    }
                    for(let j = outletMinJ_r; j < outletMaxJ_r; j++) { f.s[f._idx(f.numX-2, j)] = 1.0; } // right
                }
            }
            
            offscreenCanvas = document.createElement('canvas'); offscreenCanvas.width = f.numX; offscreenCanvas.height = f.numY;
            offscreenCtx = offscreenCanvas.getContext('2d'); imageData = offscreenCtx.createImageData(f.numX, f.numY);
        }

        function updateFlowCharacter() { if (scene.flowVelocity <= 150) game.flowState = 'Stable'; else if (scene.flowVelocity < 200) game.flowState = 'Unstable'; else game.flowState = 'Chaotic'; }
        
        function draw() {
            const f = scene.fluid; if (!f) return;
            const data = imageData.data;
            let minP = 0, maxP = 0;
            if (scene.showPressure) {
                minP = f.p[0], maxP = f.p[0];
                for (let i = 0; i < f.p.length; i++) { if (f.s[i] !== 0.0) { minP = Math.min(minP, f.p[i]); maxP = Math.max(maxP, f.p[i]); } }
            }

            for (let i = 0; i < f.numX; i++) {
                for (let j = 0; j < f.numY; j++) {
                    const idx = (j * f.numX + i) * 4;
                    const isSolid = f.s[f._idx(i, j)] === 0.0;
                    
                    if (isSolid) {
                        data.set([107, 79, 58, 255], idx); // obstacle color
                    } else if (scene.showPressure) {
                        const p = f.p[f._idx(i, j)];
                        const normP = (maxP - minP === 0) ? 0.5 : (p - minP) / (maxP - minP);
                        const r = Math.max(0, 255 * normP); 
                        const b = Math.max(0, 255 * (1.0 - normP));
                        data.set([r, 80, b, 255], idx);
                    } else {
                        if (game.state === 'BUILD_OBSTACLE') {
                            data.set([0, 0, 0, 255], idx);
                        } else {
                             const sVal = 1.0 - Math.max(0, Math.min(1, f.m[f._idx(i, j)]));
                             data.set([sVal * 0 + (1 - sVal) * 255, sVal * 128 + (1 - sVal) * 255, sVal * 255 + (1 - sVal) * 255, 255], idx);
                        }
                    }

                    if (game.state === 'BUILD_OBSTACLE') {
                        if (i === 1 && j >= f.inletMinJ && j < f.inletMaxJ) {
                             data.set([67, 232, 249, 255], idx); // Inlet: cyan
                        }
                        let isOutlet = false;
                        if (f.outlets) {
                            for (const outlet of f.outlets) {
                                if ((outlet.wall === 'bottom' && j === f.numY - 2 && i >= outlet.min && i < outlet.max) ||
                                    (outlet.wall === 'top' && j === 1 && i >= outlet.min && i < outlet.max) ||
                                    (outlet.wall === 'right' && i === f.numX - 2 && j >= outlet.min && j < outlet.max)) {
                                    isOutlet = true;
                                    break;
                                }
                            }
                        }
                        if (isOutlet) {
                             data.set([74, 222, 128, 255], idx); // Outlet: green
                        }
                    }
                }
            }
            offscreenCtx.putImageData(imageData, 0, 0);
            ctx.imageSmoothingEnabled = false; ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(offscreenCanvas, 0, 0, canvas.width, canvas.height);
            
            if (game.state === 'BUILD_OBSTACLE') {
                ctx.font = 'bold 16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                ctx.shadowBlur = 4;

                // Draw INLET text
                ctx.textAlign = 'left';
                const inletY = (f.inletMinJ + (f.inletMaxJ - f.inletMinJ) / 2) / f.numY * canvas.height;
                ctx.save();
                ctx.translate(25, inletY);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText((t('canvasLabels.inlet') || 'INLET').toUpperCase(), 0, 0);
                ctx.restore();

                // Draw OUTLET text
                ctx.textAlign = 'center';
                f.outlets.forEach(outlet => {
                    const outletLabel = (t('canvasLabels.outlet') || 'OUTLET').toUpperCase();
                    if (outlet.wall === 'bottom') {
                        const outletX = (outlet.min + (outlet.max - outlet.min) / 2) / f.numX * canvas.width;
                        ctx.fillText(outletLabel, outletX, canvas.height - 15);
                    }
                    if (outlet.wall === 'top') {
                        const outletX = (outlet.min + (outlet.max - outlet.min) / 2) / f.numX * canvas.width;
                        ctx.fillText(outletLabel, outletX, 25);
                    }
                    if (outlet.wall === 'right') {
                        const outletY = (outlet.min + (outlet.max - outlet.min) / 2) / f.numY * canvas.height;
                        ctx.save();
                        ctx.translate(canvas.width - 25, outletY);
                        ctx.rotate(Math.PI / 2);
                        ctx.fillText(outletLabel, 0, 0);
                        ctx.restore();
                    }
                });
                ctx.shadowBlur = 0; // Reset shadow
            }

            const flowStateClass = `flow-state-${game.flowState.toLowerCase()}`;
            infoDiv.innerHTML = `<p>${t('info.peakFlow')} <span class="font-semibold">${scene.flowVelocity.toFixed(2)}</span></p><p>${t('info.flowCharacter')} <span class="font-semibold ${flowStateClass}">${t('info.'+game.flowState.toLowerCase())}</span></p>`;
        }
        
        function updateUIForState() {
            // Main view toggle
            if (game.state === 'WELCOME' || game.state === 'LEARN') {
                welcomeScreen.style.display = 'flex';
                gameView.style.display = 'none';
            } else {
                welcomeScreen.style.display = 'none';
                gameView.style.display = 'flex';
            }

            Object.values(modals).forEach(m => m.classList.remove('visible'));
            mainControls.style.display = 'none'; buildControls.style.display = 'none';
            timerDiv.style.display = 'none'; 
            infoDiv.style.display = (game.level >= 3) ? 'none' : 'block';
            canalDiv.style.display = 'flex'; outflowDiv.style.display = 'block';
            pressureLegend.style.display = 'none';

            const showMainControls = () => {
                mainControls.style.display = 'flex';
                Array.from(mainControls.children).forEach(btn => btn.style.display = 'none');
                increaseBtn.disabled = true; decreaseBtn.disabled = true;
            };
            
            if(scene.showPressure) pressureLegend.style.display = 'flex';

            switch (game.state) {
                case 'WELCOME':
                    scene.paused = true;
                    break;
                case 'LEARN': 
                    modals.learn.classList.add('visible'); 
                    scene.paused = true; 
                    document.getElementById('learn-selection').style.display = 'block';
                    document.getElementById('learn-content').style.display = 'none';
                    break;
                case 'INTRO_VELOCITY': modals.intro.classList.add('visible'); scene.paused = true; break;
                case 'CHALLENGE_VELOCITY': 
                    showMainControls(); 
                    scene.paused = false; 
                    pauseBtn.style.display = 'inline-block';
                    increaseBtn.style.display = 'inline-block';
                    decreaseBtn.style.display = 'inline-block';
                    increaseBtn.disabled = false; 
                    decreaseBtn.disabled = false; 
                    startTimer(); 
                    break;
                case 'POST_CHALLENGE_VELOCITY': showMainControls(); scene.paused = true; modals.infoVelocity.classList.add('visible'); pauseBtn.style.display = 'inline-block'; break;
                case 'GAME_OVER_VELOCITY_FAIL': scene.paused = true; modals.failVelocity.classList.add('visible'); break;
                case 'INTRO_PRESSURE': scene.paused = true; modals.pressureIntro.classList.add('visible'); break;
                case 'CHALLENGE_PRESSURE': 
                    showMainControls(); 
                    scene.paused = false; 
                    submitVelocityBtn.style.display = 'inline-block'; 
                    increaseBtn.style.display = 'inline-block';
                    decreaseBtn.style.display = 'inline-block';
                    increaseBtn.disabled = false; 
                    decreaseBtn.disabled = false; 
                    infoDiv.style.display = 'none'; 
                    break;
                case 'POST_CHALLENGE_PRESSURE': 
                    showMainControls(); 
                    scene.paused = true; 
                    modals.infoPressure.classList.add('visible'); 
                    pressureLegend.style.display = 'flex';
                    break;
                case 'GAME_OVER_PRESSURE_FAIL': scene.paused = true; document.getElementById('your-velocity-display').textContent = scene.flowVelocity.toFixed(2); document.getElementById('target-velocity-display-pressure-fail').textContent = game.targetVelocity.toFixed(2); modals.failPressure.classList.add('visible'); break;
                case 'INTRO_OBSTACLE': scene.paused = true; modals[`obstacleIntro${game.level}`].classList.add('visible'); break;
                case 'BUILD_OBSTACLE': 
                    scene.paused = true; 
                    buildControls.style.display = 'flex'; 
                    canalDiv.style.display = 'none'; 
                    outflowDiv.style.display = 'none'; 
                    if (game.buildModeActive) toggleBuildMode();
                    break;
                case 'SIMULATE_OBSTACLE':
                    scene.paused = false; buildControls.style.display = 'none';
                    mainControls.style.display = 'flex';
                    Array.from(mainControls.children).forEach(btn => btn.style.display = 'none');
                    pressureBtn.style.display = 'inline-block';
                    canalDiv.style.display = 'none'; outflowDiv.style.display = 'none';
                    break;
                case 'GAME_OVER_OBSTACLE_FAIL': scene.paused = true; modals.obstacleFail.classList.add('visible'); break;
                case 'LEVEL_WIN': scene.paused = true; modals.levelWin.classList.add('visible'); break;
                case 'FINAL_WIN': scene.paused = true; modals.win.classList.add('visible'); calculateEndGameStats(); break;
            }
            pauseBtn.textContent = scene.paused ? t('mainControls.play') : t('mainControls.pause'); pauseBtn.classList.toggle('active', scene.paused);
            pressureBtn.textContent = scene.showPressure ? t('mainControls.showDye') : t('mainControls.showPressure'); pressureBtn.classList.toggle('active', scene.showPressure);
            buildChannelBtn.textContent = game.buildModeActive ? t('buildControls.stopBuilding') : t('buildControls.buildChannel');
        }
        function startTimer() {
            timerDiv.style.display = 'block'; game.timerValue = 10; timerDiv.textContent = game.timerValue;
            if (game.timerInterval) clearInterval(game.timerInterval);
            game.timerInterval = setInterval(() => {
                game.timerValue--; timerDiv.textContent = game.timerValue;
                if (game.timerValue <= 0) {
                    clearInterval(game.timerInterval);
                    if (scene.flowVelocity >= 200) { game.targetVelocity = scene.flowVelocity; game.state = 'POST_CHALLENGE_VELOCITY'; } 
                    else { game.state = 'GAME_OVER_VELOCITY_FAIL'; }
                    updateUIForState();
                }
            }, 1000);
        }
        function handleObstacleLevelEnd() {
            scene.paused = true;
            const ratio = calculateFlowRatio();
            if (ratio === "N/A") {
                game.state = 'GAME_OVER_OBSTACLE_FAIL';
            } else {
                if (game.level < 5) {
                    document.getElementById('level-flow-ratio-display').textContent = ratio;
                    game.state = 'LEVEL_WIN';
                } else {
                    game.flowRatio = ratio; // Store for final screen
                    game.state = 'FINAL_WIN';
                }
            }
            updateUIForState();
        }
        function startObstacleTimer() {
            timerDiv.style.display = 'block';
            switch (game.level) {
                case 3: game.obstacleTimerValue = 15; break;
                case 4: game.obstacleTimerValue = 15; break;
                case 5: game.obstacleTimerValue = 15; break;
                default: game.obstacleTimerValue = 15;
            }
            timerDiv.textContent = game.obstacleTimerValue;
            if (game.obstacleTimerInterval) clearInterval(game.obstacleTimerInterval);
            game.obstacleTimerInterval = setInterval(() => {
                game.obstacleTimerValue--;
                timerDiv.textContent = game.obstacleTimerValue;
                if (game.obstacleTimerValue <= 0) {
                    clearInterval(game.obstacleTimerInterval);
                    game.obstacleTimerInterval = null;
                    handleObstacleLevelEnd();
                }
            }, 1000);
        }
        
        function mainLoop() {
            if (!scene.fluid) { setupScene(); requestAnimationFrame(mainLoop); return; }
            if (!scene.paused) {
                scene.fluid.simulate(scene.dt, scene.numIters, scene.overRelaxation, scene.flowVelocity, scene.viscosity);
            }
            updateFlowCharacter(); draw();
            requestAnimationFrame(mainLoop);
        }
        function resetGame() {
            if (game.timerInterval) clearInterval(game.timerInterval);
            if (game.obstacleTimerInterval) clearInterval(game.obstacleTimerInterval);
            game.obstacleTimerInterval = null;
            game.level = 1;
            setupScene(1); scene.flowVelocity = 5.0; game.totalGameStartTime = Date.now();
            game.targetVelocity = 0;
            scene.showPressure = false;
            game.state = 'WELCOME'; 
            updateTexts();
        }
        function resetPressureChallenge() {
            setupScene(2);
            scene.flowVelocity = 5.0;
            game.state = 'CHALLENGE_PRESSURE';
            updateUIForState();
        }

        // --- Event Handlers & UI Logic ---
        increaseBtn.addEventListener('click', () => scene.flowVelocity += 5.0);
        decreaseBtn.addEventListener('click', () => scene.flowVelocity = Math.max(0.0, scene.flowVelocity - 5.0));
        pauseBtn.addEventListener('click', () => { if (game.state === 'CHALLENGE_VELOCITY' || game.state === 'POST_CHALLENGE_VELOCITY') { scene.paused = !scene.paused; updateUIForState(); } });
        pressureBtn.addEventListener('click', () => { scene.showPressure = !scene.showPressure; updateUIForState(); });
        submitVelocityBtn.addEventListener('click', () => {
            if (Math.abs(scene.flowVelocity - game.targetVelocity) > 20) { game.state = 'GAME_OVER_PRESSURE_FAIL'; } 
            else { game.state = 'POST_CHALLENGE_PRESSURE'; scene.showPressure = true; }
            updateUIForState();
        });
        function handleCloseVelocityPopup() {
            modals.infoVelocity.classList.remove('visible'); scene.paused = false;
            mainControls.style.display = 'flex'; increaseBtn.disabled = true; decreaseBtn.disabled = true; pauseBtn.style.display = 'none';
            setTimeout(() => {
                game.state = 'INTRO_PRESSURE';
                document.getElementById('target-velocity-display').parentElement.innerHTML = game.targetVelocity.toFixed(2);
                updateUIForState();
            }, 5000);
        }
        function handleStartPressureChallenge() {
            setupScene(2); scene.flowVelocity = 5.0;
            game.state = 'CHALLENGE_PRESSURE'; updateUIForState();
        }
        function handleClosePressurePopup() {
            modals.infoPressure.classList.remove('visible'); scene.paused = false;
            mainControls.style.display = 'flex'; Array.from(mainControls.children).forEach(btn => btn.style.display = 'none');
            setTimeout(() => { game.level = 3; game.state = 'INTRO_OBSTACLE'; updateUIForState(); }, 5000);
        }

        function drawObstacle(i, j, size = 5) {
            const f = scene.fluid; if (!f) return;
            const half = Math.floor(size / 2);
            for (let dx = -half; dx <= half; dx++) {
                for (let dy = -half; dy <= half; dy++) {
                    const ci = i + dx, cj = j + dy;
                    if (ci > 0 && ci < f.numX - 1 && cj > 0 && cj < f.numY - 1) {
                        if(dx*dx + dy*dy < (half+0.5)**2) {
                             f.s[f._idx(ci, cj)] = 0.0;
                        }
                    }
                }
            }
        }
        function handleCanvasDraw(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            const i = Math.floor(x / canvas.width * scene.fluid.numX);
            const j = Math.floor(y / canvas.height * scene.fluid.numY);
            drawObstacle(i, j);
        }

        function handleTouchDraw(touch) {
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left, y = touch.clientY - rect.top;
            const i = Math.floor(x / canvas.width * scene.fluid.numX);
            const j = Math.floor(y / canvas.height * scene.fluid.numY);
            drawObstacle(i, j);
        }

        canvas.addEventListener('mousemove', e => { 
            if (game.state === 'BUILD_OBSTACLE' && game.buildModeActive && e.buttons === 1) {
                handleCanvasDraw(e);
            }
        });
        canvas.addEventListener('mousedown', e => { 
            if (game.state === 'BUILD_OBSTACLE' && game.buildModeActive) {
                handleCanvasDraw(e);
            }
        });

        canvas.addEventListener('touchmove', e => { 
            if (game.state === 'BUILD_OBSTACLE' && game.buildModeActive) {
                e.preventDefault();
                handleTouchDraw(e.touches[0]);
            }
        });
        canvas.addEventListener('touchstart', e => { 
             if (game.state === 'BUILD_OBSTACLE' && game.buildModeActive) {
                e.preventDefault();
                handleTouchDraw(e.touches[0]);
            }
        });

        function calculateFlowRatio() {
            const f = scene.fluid; if (!f) return "N/A";
            let inletVelSum = 0, outletVelSum = 0; const offset = 3; 
            const inletSampleI = 1 + offset;
            if (inletSampleI < f.numX - 1) {
                for(let j = f.inletMinJ; j < f.inletMaxJ; j++) { inletVelSum += Math.abs(f.u[f._idx(inletSampleI, j)]); }
            }
            for (const outlet of f.outlets) {
                 if (outlet.wall === 'bottom') {
                     const sampleJ = f.numY - 1 - offset;
                     if (sampleJ > 1) { for (let i = outlet.min; i < outlet.max; i++) { outletVelSum += Math.abs(f.v[f._idx(i, sampleJ)]); } }
                 } else if (outlet.wall === 'top') {
                     const sampleJ = 1 + offset;
                     if (sampleJ < f.numY - 1) { for (let i = outlet.min; i < outlet.max; i++) { outletVelSum += Math.abs(f.v[f._idx(i, sampleJ)]); } }
                 } else if (outlet.wall === 'right') {
                     const sampleI = f.numX - 1 - offset;
                     if (sampleI > 1) { for (let j = outlet.min; j < outlet.max; j++) { outletVelSum += Math.abs(f.u[f._idx(sampleI, j)]); } }
                 }
            }
            return (inletVelSum > 0.1) ? (outletVelSum / inletVelSum).toFixed(2) : "N/A";
        }
        function calculateEndGameStats() {
            const totalMs = Date.now() - game.totalGameStartTime;
            const minutes = Math.floor(totalMs / 60000);
            const seconds = ((totalMs % 60000) / 1000).toFixed(0);
            const finalRatio = game.flowRatio || calculateFlowRatio();
            document.querySelector('#win-modal [data-t="winModal.totalTime"]').innerHTML = `${t('winModal.totalTime')} <strong id="total-time-display">${minutes}:${seconds.padStart(2, '0')}</strong>`;
            document.querySelector('#win-modal [data-t="winModal.finalFlowRatio"]').innerHTML = `${t('winModal.finalFlowRatio')} <strong id="flow-ratio-display">${finalRatio}</strong>`;
        }

        function showLearnContent(level) {
            document.getElementById('learn-selection').style.display = 'none';
            const learnContentEl = document.getElementById('learn-content');
            learnContentEl.style.display = 'block';
            const titleEl = document.getElementById('learn-title');
            const textEl = document.getElementById('learn-text');

            if (level === 'beginner') {
                titleEl.textContent = t('learnModal.beginnerTitle');
                textEl.innerHTML = t('learnModal.beginnerText');
            } else {
                titleEl.textContent = t('learnModal.advancedTitle');
                textEl.innerHTML = t('learnModal.advancedText');
            }
        }
        
        document.querySelectorAll('.lang-btn').forEach(btn => {
            btn.addEventListener('click', e => {
                const lang = e.target.dataset.lang;
                if(game.language === lang) return;
                game.language = lang;
                document.querySelector('.lang-btn.active').classList.remove('active');
                e.target.classList.add('active');
                updateTexts();
            });
        });


        let resizeTimeout;
        window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => setupScene(game.level), 100); });
        
        // --- Initial Setup ---
        resetGame();
        requestAnimationFrame(mainLoop);
    </script>
</body>
</html>
