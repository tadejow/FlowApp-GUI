<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Duck Race - FlowApp</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            background-color: #111827;
        }
        .hidden { display: none; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(250, 204, 21, 0); }
            100% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0); }
        }
        .welcome-panel {
            background: rgba(31, 41, 55, 0.7);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid #374151;
            animation: fadeIn 0.8s ease-out forwards;
            opacity: 0;
        }
        .btn { transition: all 0.2s ease; }
        .btn:active { transform: scale(0.95); }
        .btn-primary { animation: pulse 2s infinite; }
        .btn-primary:hover { transform: translateY(-3px) scale(1.05); }
        .btn-secondary:hover { background-color: #374151; border-color: #facc15; }
        .lang-btn.active { background-color: #facc15; color: #111827; border-color: #fde047; font-weight: bold; }
        .fact-modal { animation: fadeIn 0.3s ease-out forwards; }
    </style>
</head>
<body class="text-white">
    <main class="relative w-screen h-screen flex items-center justify-center bg-cover bg-center" style="background-image: url('../assets/duck-background.jpg')">
        <div id="main-overlay" class="absolute inset-0 bg-blue-900 bg-opacity-40 backdrop-blur-sm"></div>

        <div id="start-screen" class="relative z-10 text-center p-4">
             <div class="welcome-panel p-8 md:p-12 rounded-xl shadow-2xl max-w-xl w-full">
                <h1 class="text-4xl md:text-5xl font-bold text-yellow-300 mb-2" data-t="title">Duck Race</h1>
                <p class="text-lg text-cyan-200 mb-8" data-t="subtitle">First duck to cross the finish line wins!</p>
                <div class="flex flex-col items-center gap-4">
                    <button id="start-button" class="btn btn-primary w-full md:w-auto px-8 py-3 bg-yellow-400 text-gray-900 font-bold rounded-lg shadow-lg" data-t="startButton">
                        Start Race
                    </button>
                    <button id="learn-button" class="btn btn-secondary w-full md:w-auto px-6 py-3 bg-gray-700/50 border border-gray-600 text-yellow-300 font-bold rounded-lg" data-t="learnButton">
                        Learn about river ecosystems
                    </button>
                    <div id="lang-switcher" class="mt-4 p-2 bg-black bg-opacity-50 rounded-lg flex gap-2">
                        <button class="lang-btn px-4 py-1 rounded" data-lang="en">EN</button>
                        <button class="lang-btn px-4 py-1 rounded" data-lang="pl">PL</button>
                        <button class="lang-btn px-4 py-1 rounded" data-lang="de">DE</button>
                        <button class="lang-btn px-4 py-1 rounded" data-lang="cs">CS</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="level-complete-screen" class="relative z-10 text-center bg-black bg-opacity-70 p-10 rounded-xl hidden">
            <h2 id="level-complete-title" class="text-5xl font-bold text-yellow-300 mb-4"></h2>
            <p id="level-complete-stats" class="text-xl text-cyan-200 mb-6"></p>
            <p id="level-complete-desc" class="text-2xl text-white mb-6"></p>
            <button id="next-level-button" class="px-8 py-4 bg-green-500 text-white font-bold rounded-lg shadow-lg hover:bg-green-600"></button>
        </div>
        
        <div id="final-win-screen" class="relative z-10 text-center bg-black bg-opacity-70 p-10 rounded-xl hidden">
            <h2 class="text-5xl font-bold text-yellow-300 mb-4" data-t="finalWinTitle">Race Completed!</h2>
            <p class="text-2xl text-white mb-2" data-t="finalWinCongrats">Congratulations, you beat all 5 levels!</p>
            <p class="text-xl text-cyan-200 mb-8" data-t="finalWinTimeLabel">Your final time:</p>
            <p id="final-time-display" class="text-4xl font-mono text-yellow-300 mb-8"></p>
            <button id="close-and-save-button" class="px-8 py-4 bg-blue-500 text-white font-bold rounded-lg shadow-lg hover:bg-blue-600" data-t="finalWinButton">
                Save score and return to app
            </button>
        </div>

        <div id="game-over-screen" class="relative z-10 text-center bg-black bg-opacity-70 p-10 rounded-xl hidden">
            <h2 class="text-5xl font-bold text-yellow-300 mb-4" data-t="gameOverTitle">Race Over!</h2>
            <p id="game-over-text" class="text-3xl text-white mb-6"></p>
            <p id="game-over-stats" class="text-xl text-cyan-200 mb-6"></p>
            <button id="restart-button" class="px-8 py-4 bg-yellow-400 text-gray-900 font-bold rounded-lg shadow-lg hover:bg-yellow-500" data-t="restartButton">
                Race Again
            </button>
        </div>

        <div id="game-canvas-container" class="relative z-10 flex flex-col items-center hidden">
            <div id="game-ui" class="text-white bg-black bg-opacity-50 px-4 py-2 rounded-t-lg flex justify-between items-center w-full">
                <div>
                    <h2 id="level-display" class="text-xl font-bold text-yellow-300"></h2>
                    <p class="text-sm text-cyan-100" data-t="gameHint">Click water to splash, click garbage for +10 points!</p>
                </div>
                 <div class="text-center mx-4">
                    <p class="text-lg font-bold"><span data-t="scoreLabel">Score</span>: <span id="score-display" class="font-mono">0</span></p>
                    <p class="text-lg font-bold"><span data-t="timeLabel">Time</span>: <span id="time-display" class="font-mono">00:00</span></p>
                </div>
                <div class="w-48"></div>
            </div>
            <canvas id="game-canvas" class="bg-blue-800 bg-opacity-80 border-4 border-yellow-400 rounded-b-lg shadow-2xl"></canvas>
        </div>

        <div id="learn-modal" class="absolute inset-0 z-20 bg-black bg-opacity-75 flex items-center justify-center hidden p-4">
            <div class="bg-gray-800 text-white p-8 rounded-lg max-w-3xl text-left shadow-2xl leading-relaxed">
                <h2 class="text-3xl font-bold text-cyan-300 mb-4" data-t="learnModal.title">River Ecosystems of the Tri-Border Region</h2>
                <div data-t-html="learnModal.text"><p>Rivers like the Mandau and Neisse are more than just flowing water; they are vital lifelines for the entire tri-border region of Germany, Poland, and the Czech Republic.</p><p class="mt-4"><strong>A Corridor for Life:</strong> Rivers act as natural corridors, connecting forests, meadows, and wetlands. This allows animals like otters, beavers, and kingfishers to move safely between habitats to find food and mates. For fish such as trout and grayling, the river is their entire world, providing spawning grounds in gravelly shallows and shelter in deeper pools.</p><p class="mt-4"><strong>The Unseen Workforce:</strong> The riverbed is teeming with microorganisms and insects. These tiny workers break down fallen leaves and other organic matter, recycling nutrients back into the ecosystem. This process is fundamental to keeping the water clean and supporting the entire food web, from the smallest algae to the largest predatory fish.</p><p class="mt-4"><strong>Zittau and the Mandau:</strong> The city of Zittau has a long history intertwined with the Mandau. While historical modifications, like straightening channels, were made to protect against floods, there is now a growing understanding of the need to restore natural river features. Creating more natural banks and allowing for varied flow helps improve water quality and brings back biodiversity, making the river a healthier and more resilient ecosystem for everyone.</p></div>
                <button id="close-learn-modal" class="mt-6 w-full px-6 py-3 bg-cyan-600 text-white font-bold rounded-lg shadow-lg hover:bg-cyan-700" data-t="closeButton">Close</button>
            </div>
        </div>
        
        <div id="fact-modal" class="absolute top-5 right-5 z-20 bg-gray-800 text-white p-6 rounded-lg max-w-sm shadow-2xl fact-modal hidden">
            <h3 class="text-xl font-bold text-yellow-300 mb-3" data-t="factTitle">Did you know?</h3>
            <p id="fact-text" class="text-md mb-4"></p>
            <button id="close-fact-modal" class="w-full px-4 py-2 bg-blue-500 text-white font-bold rounded-lg hover:bg-blue-600" data-t="closeButton">Close</button>
        </div>
    </main>

    <script type="module">
        document.addEventListener('DOMContentLoaded', () => {
            const GameState = { StartScreen: 0, Playing: 1, GameOver: 2, LevelComplete: 3, FinalWin: 4 };
            const PlayerType = { Human: 0, Bot: 1 };
            const ObstacleType = { Log: 0, Garbage: 1 };

            const translations = {
                en: {
                    title: "Duck Race", subtitle: "First duck to cross the finish line wins!", startButton: "Start Race",
                    learnButton: "Learn about river ecosystems", restartButton: "Race Again",
                    finalWinTitle: "Race Completed!", finalWinCongrats: "Congratulations, you beat all 5 levels!",
                    finalWinTimeLabel: "Your final time:", finalWinButton: "Save score and return to app",
                    gameOverTitle: "Race Over!", gameHint: "Click water to splash, click garbage for +10 points!",
                    scoreLabel: "Score", timeLabel: "Time", closeButton: "Close", factTitle: "Did you know?",
                    learnModal: {
                        title: "River Ecosystems of the Tri-Border Region",
                        text: `<p>Rivers like the Mandau and Neisse are more than just flowing water; they are vital lifelines for the entire tri-border region of Germany, Poland, and the Czech Republic.</p><p class="mt-4"><strong>A Corridor for Life:</strong> Rivers act as natural corridors, connecting forests, meadows, and wetlands. This allows animals like otters, beavers, and kingfishers to move safely between habitats to find food and mates. For fish such as trout and grayling, the river is their entire world, providing spawning grounds in gravelly shallows and shelter in deeper pools.</p><p class="mt-4"><strong>The Unseen Workforce:</strong> The riverbed is teeming with microorganisms and insects. These tiny workers break down fallen leaves and other organic matter, recycling nutrients back into the ecosystem. This process is fundamental to keeping the water clean and supporting the entire food web, from the smallest algae to the largest predatory fish.</p><p class="mt-4"><strong>Zittau and the Mandau:</strong> The city of Zittau has a long history intertwined with the Mandau. While historical modifications, like straightening channels, were made to protect against floods, there is now a growing understanding of the need to restore natural river features. Creating more natural banks and allowing for varied flow helps improve water quality and brings back biodiversity, making the river a healthier and more resilient ecosystem for everyone.</p>`
                    },
                    levelComplete: (level) => `Level ${level} Complete!`,
                    nextLevelDesc: { 2: "Next: Polluted Pass. Garbage will send you back to the start!", 3: "Next: Tricky Turn. A mix of logs and garbage awaits.", 4: "Next: The Rapids! The current is much faster here!", 5: "Next: The Foggy Finish! Navigate through thick fog to win!" },
                    nextLevelButton: (level) => `Start Level ${level}`,
                    gameOverLost: "You lost the race!",
                    gameOverChampion: "🎉 You beat all the levels! You're the champion! 🎉",
                    gameOverBotWon: (name) => `${name} won the race!`
                },
                pl: {
                    title: "Wyścig Kaczek", subtitle: "Pierwsza kaczka na mecie wygrywa!", startButton: "Rozpocznij Wyścig",
                    learnButton: "Dowiedz się o ekosystemach rzecznych", restartButton: "Jeszcze Raz",
                    finalWinTitle: "Wyścig Ukończony!", finalWinCongrats: "Gratulacje, ukończyłeś wszystkie 5 poziomów!",
                    finalWinTimeLabel: "Twój końcowy czas:", finalWinButton: "Zapisz wynik i wróć do aplikacji",
                    gameOverTitle: "Koniec Wyścigu!", gameHint: "Kliknij wodę by chlapać, kliknij śmieci by dostać +10 punktów!",
                    scoreLabel: "Punkty", timeLabel: "Czas", closeButton: "Zamknij", factTitle: "Czy wiesz, że?",
                    learnModal: {
                        title: "Ekosystemy rzeczne Trójstyku",
                        text: `<p>Rzeki takie jak Mandau i Nysa to coś więcej niż tylko płynąca woda; to życiodajne arterie dla całego regionu trójstyku granic Polski, Czech i Niemiec.</p><p class="mt-4"><strong>Korytarz Życia:</strong> Rzeki działają jako naturalne korytarze, łącząc lasy, łąki i tereny podmokłe. Umożliwia to zwierzętom, takim jak wydry, bobry i zimorodki, bezpieczne przemieszczanie się między siedliskami w poszukiwaniu pożywienia i partnerów. Dla ryb, takich jak pstrąg i lipień, rzeka to cały świat, zapewniający miejsca do tarła na żwirowych płyciznach i schronienie w głębszych partiach.</p><p class="mt-4"><strong>Niewidzialni Pracownicy:</strong> Dno rzeki tętni życiem mikroorganizmów i owadów. Ci mali pracownicy rozkładają opadłe liście i inną materię organiczną, przywracając składniki odżywcze do ekosystemu. Proces ten jest fundamentalny dla utrzymania czystości wody i wspierania całej sieci pokarmowej, od najmniejszych glonów po największe drapieżne ryby.</p><p class="mt-4"><strong>Zittau i Mandau:</strong> Miasto Zittau ma długą historię splecioną z rzeką Mandau. Chociaż historyczne modyfikacje, takie jak prostowanie koryt, miały na celu ochronę przed powodziami, obecnie rośnie zrozumienie potrzeby przywracania naturalnych cech rzek. Tworzenie bardziej naturalnych brzegów i umożliwienie zróżnicowanego przepływu pomaga poprawić jakość wody i przywraca bioróżnorodność, czyniąc rzekę zdrowszym i bardziej odpornym ekosystemem dla wszystkich.</p>`
                    },
                    levelComplete: (level) => `Poziom ${level} Ukończony!`,
                    nextLevelDesc: { 2: "Następny: Zanieczyszczona Przełęcz. Śmieci cofną cię na start!", 3: "Następny: Podstępny Zakręt. Czeka na ciebie mieszanka kłód i śmieci.", 4: "Następny: Bystrza! Prąd jest tu znacznie szybszy!", 5: "Następny: Mglisty Finisz! Przebij się przez gęstą mgłę, aby wygrać!" },
                    nextLevelButton: (level) => `Rozpocznij Poziom ${level}`,
                    gameOverLost: "Przegrałeś wyścig!",
                    gameOverChampion: "🎉 Ukończyłeś wszystkie poziomy! Jesteś mistrzem! 🎉",
                    gameOverBotWon: (name) => `${name} wygrał wyścig!`
                },
                de: { /* German translations */ },
                cs: { /* Czech translations */ }
            };

            const facts = { /* ... facts translations ... */ };

            const LEVEL_CONFIGS = [
                { level: 1, flow: 0.5, spawnRate: 500, maxObs: 15, types: [ObstacleType.Log], hasFog: false, name: "The Calm River" },
                { level: 2, flow: 0.5, spawnRate: 450, maxObs: 20, types: [ObstacleType.Garbage], hasFog: false, name: "Polluted Pass" },
                { level: 3, flow: 0.6, spawnRate: 400, maxObs: 25, types: [ObstacleType.Log, ObstacleType.Garbage], hasFog: false, name: "Tricky Turn" },
                { level: 4, flow: 1.0, spawnRate: 300, maxObs: 30, types: [ObstacleType.Log, ObstacleType.Garbage], hasFog: false, name: "The Rapids" },
                { level: 5, flow: 0.9, spawnRate: 320, maxObs: 35, types: [ObstacleType.Log, ObstacleType.Garbage], hasFog: true, name: "The Foggy Finish" }
            ];
            const MAX_LEVEL = LEVEL_CONFIGS.length;
            const SIM_HEIGHT = 1.1, CANVAS_HEIGHT = 300, CANVAS_WIDTH = 1200;
            const C_SCALE = CANVAS_HEIGHT / SIM_HEIGHT, SIM_WIDTH = CANVAS_WIDTH / C_SCALE;
            const RESOLUTION = 30, DT = 1.0 / 60.0, NUM_ITERS = 20;
            const OVER_RELAXATION = 1.9, NUM_PLAYERS = 3, DUCK_SIZE = 12;
            const FINISH_LINE_X = 0.95, SPLASH_EFFECT_RADIUS = 0.5;
            const STUN_DURATION = 1.5, FLUID_FORCE_FACTOR = 0.1, DAMPING_FACTOR = 0.80;
            const SPLASH_RADIUS_RATE = 60, SPLASH_OPACITY_RATE = 1.2, OBSTACLE_FLUID_FORCE_FACTOR = DT;
            const RIVERBANK_MARGIN = 0.05 * SIM_HEIGHT, FOG_START_X = 0.6, SCORE_PER_GARBAGE = 10;
            const SPLASH_STRENGTH = 2.5, BOT_SPLASH_STRENGTH = 1.5;
            const BOT_AVOID_DISTANCE = 0.3, BOT_OFFENSIVE_RANGE = 0.4, BOT_OFFENSIVE_CHANCE = 0.3;

            const U_FIELD = 0, V_FIELD = 0.5, S_FIELD = 1.0;
            class FluidSimulator {
                constructor(density, numX, numY, h) { this.density = density; this.h = h; this.numX = numX + 2; this.numY = numY + 2; const createGrid = (fill = 0.0) => Array(this.numX).fill(0).map(() => Array(this.numY).fill(fill)); this.u = createGrid(); this.v = createGrid(); this.p = createGrid(); this.s = createGrid(); this.m = createGrid(1.0); const pipeH = 0.8 * this.numY; this.inletMinJ = Math.floor(0.5 * this.numY - 0.5 * pipeH); this.inletMaxJ = Math.floor(0.5 * this.numY + 0.5 * pipeH); for (let i = 0; i < this.numX; i++) for (let j = 0; j < this.numY; j++) this.s[i][j] = (i === 0 || j === 0 || j === this.numY - 1) ? 0.0 : 1.0; }
                integrate(dt, gravity) { for (let i = 1; i < this.numX; i++) for (let j = 1; j < this.numY - 1; j++) if (this.s[i][j] !== 0.0 && this.s[i][j - 1] !== 0.0) this.v[i][j] += gravity * dt; }
                solveIncompressibility(numIters, dt, overRelaxation) { const cp = this.density * this.h / dt; for (let iter = 0; iter < numIters; iter++) for (let i = 1; i < this.numX - 1; i++) for (let j = 1; j < this.numY - 1; j++) { if (this.s[i][j] === 0.0) continue; const s_sum = this.s[i - 1][j] + this.s[i + 1][j] + this.s[i][j - 1] + this.s[i][j + 1]; if (s_sum === 0.0) continue; const div = this.u[i + 1][j] - this.u[i][j] + this.v[i][j + 1] - this.v[i][j]; const pressureChange = -div / s_sum * overRelaxation; this.p[i][j] += cp * pressureChange; this.u[i][j] -= this.s[i - 1][j] * pressureChange; this.u[i + 1][j] += this.s[i + 1][j] * pressureChange; this.v[i][j] -= this.s[i][j - 1] * pressureChange; this.v[i][j + 1] += this.s[i][j + 1] * pressureChange; } }
                extrapolate() { for (let i = 0; i < this.numX; i++) { this.u[i][0] = this.u[i][1]; this.u[i][this.numY - 1] = this.u[i][this.numY - 2]; } for (let j = 0; j < this.numY; j++) { this.v[0][j] = this.v[1][j]; this.v[this.numX - 1][j] = this.v[this.numX - 2][j]; } }
                sampleField(x, y, fieldType, fieldData) { const h1 = 1.0 / this.h, h2 = 0.5 * this.h; x = Math.max(Math.min(x, this.numX * this.h), this.h); y = Math.max(Math.min(y, this.numY * this.h), this.h); let dx = 0.0, dy = 0.0; if (fieldType === U_FIELD) dy = h2; else if (fieldType === V_FIELD) dx = h2; else if (fieldType === S_FIELD) { dx = h2; dy = h2; } const x0 = Math.min(Math.floor((x - dx) * h1), this.numX - 2); const tx = ((x - dx) - x0 * this.h) * h1; const x1 = Math.min(x0 + 1, this.numX - 2); const y0 = Math.min(Math.floor((y - dy) * h1), this.numY - 2); const ty = ((y - dy) - y0 * this.h) * h1; const y1 = Math.min(y0 + 1, this.numY - 2); const sx = 1.0 - tx, sy = 1.0 - ty; return (sx * sy * fieldData[x0][y0] + tx * sy * fieldData[x1][y0] + tx * ty * fieldData[x1][y1] + sx * ty * fieldData[x0][y1]); }
                advectVel(dt) { const newU = this.u.map(row => [...row]); const newV = this.v.map(row => [...row]); const h2 = 0.5 * this.h; for (let i = 1; i < this.numX - 1; i++) for (let j = 1; j < this.numY - 1; j++) { if (this.s[i][j] !== 0.0 && this.s[i - 1][j] !== 0.0) { const avgV = (this.v[i - 1][j] + this.v[i][j] + this.v[i - 1][j + 1] + this.v[i][j + 1]) * 0.25; let posX = i * this.h, posY = j * this.h + h2; posX -= dt * this.u[i][j]; posY -= dt * avgV; newU[i][j] = this.sampleField(posX, posY, U_FIELD, this.u); } if (this.s[i][j] !== 0.0 && this.s[i][j - 1] !== 0.0) { const avgU = (this.u[i][j - 1] + this.u[i][j] + this.u[i + 1][j - 1] + this.u[i + 1][j]) * 0.25; let posX = i * this.h + h2, posY = j * this.h; posX -= dt * avgU; posY -= dt * this.v[i][j]; newV[i][j] = this.sampleField(posX, posY, V_FIELD, this.v); } } this.u = newU; this.v = newV; }
                advectSmoke(dt) { const newM = this.m.map(row => [...row]); const h2 = 0.5 * this.h; for (let i = 1; i < this.numX - 1; i++) for (let j = 1; j < this.numY - 1; j++) if (this.s[i][j] !== 0.0) { const avgU = (this.u[i][j] + this.u[i + 1][j]) * 0.5; const avgV = (this.v[i][j] + this.v[i][j + 1]) * 0.5; const x = i * this.h + h2 - dt * avgU; const y = j * this.h + h2 - dt * avgV; newM[i][j] = this.sampleField(x, y, S_FIELD, this.m); } this.m = newM; }
                simulate(dt, gravity, numIters, overRelaxation, flowVelocity, currentTime) { for (let j = 1; j < this.numY - 1; j++) this.u[1][j] = 0.0; const inletCenterJ = (this.inletMinJ + this.inletMaxJ) / 2.0; const inletHalfWidth = (this.inletMaxJ - this.inletMinJ) / 2.0; const waveFrequency = 2.0, waveAmplitude = 0.4; const timeBasedVelocity = flowVelocity * (1.0 + waveAmplitude * Math.cos(currentTime * waveFrequency)); if (inletHalfWidth > 0) for (let j = this.inletMinJ; j < this.inletMaxJ; j++) { const relativePos = (j - inletCenterJ) / inletHalfWidth; const speed = timeBasedVelocity * (1 - relativePos * relativePos); this.u[1][j] = Math.max(0.0, speed); } for (let j = this.inletMinJ; j < this.inletMaxJ; j++) this.m[1][j] = 0.0; this.integrate(dt, gravity); for (let i = 0; i < this.numX; i++) for (let j = 0; j < this.numY; j++) this.p[i][j] = 0.0; this.solveIncompressibility(numIters, dt, overRelaxation); this.extrapolate(); this.advectVel(dt); this.advectSmoke(dt); }
            }

            let currentLang = 'en';
            let availableFacts = [];
            let currentGameState = GameState.StartScreen;
            let winner = null, level = 1, animationFrameId = 0, isGameOver = false, score = 0;
            let levelStartTime = 0, totalTimeMs = 0, finalCompletionTimeMs = 0;
            let fluid = null, ducks = [], obstacles = [], splashes = [];
            let lastObstacleSpawnTime = 0, lastFrameTime = performance.now();
            
            const screens = { start: document.getElementById('start-screen'), levelComplete: document.getElementById('level-complete-screen'), gameOver: document.getElementById('game-over-screen'), canvasContainer: document.getElementById('game-canvas-container'), finalWin: document.getElementById('final-win-screen'), };
            const canvas = document.getElementById('game-canvas'); const ctx = canvas.getContext('2d');
            const gameUi = document.getElementById('game-ui'); const startButton = document.getElementById('start-button');
            const nextLevelButton = document.getElementById('next-level-button'); const restartButton = document.getElementById('restart-button');
            const levelDisplay = document.getElementById('level-display'); const levelCompleteTitle = document.getElementById('level-complete-title');
            const levelCompleteDesc = document.getElementById('level-complete-desc'); const levelCompleteStats = document.getElementById('level-complete-stats');
            const gameOverText = document.getElementById('game-over-text'); const gameOverStats = document.getElementById('game-over-stats');
            const scoreDisplay = document.getElementById('score-display'); const timeDisplay = document.getElementById('time-display');
            const finalTimeDisplay = document.getElementById('final-time-display'); const closeAndSaveButton = document.getElementById('close-and-save-button');
            const factModal = document.getElementById('fact-modal'); const factText = document.getElementById('fact-text');
            const closeFactModal = document.getElementById('close-fact-modal'); const learnModal = document.getElementById('learn-modal');

            function t(key, ...args) { const langDict = translations[currentLang] || translations.en; const value = key.split('.').reduce((obj, k) => (obj && obj[k] !== undefined) ? obj[k] : undefined, langDict); if (typeof value === 'function') return value(...args); return value || key; }
            function updateAllTexts() { document.querySelectorAll('[data-t]').forEach(el => { const key = el.dataset.t; const value = t(key); el.textContent = value; }); document.querySelectorAll('[data-t-html]').forEach(el => { const key = el.dataset.tHtml; el.innerHTML = t(key); });}
            function formatTime(ms) { const seconds = Math.floor(ms / 1000); const milliseconds = Math.floor(ms % 1000).toString().padStart(3, '0'); return `${seconds}:${milliseconds}`; }
            function showRandomFact() { if (availableFacts.length === 0) availableFacts = [...(facts[currentLang] || facts.en)]; const factIndex = Math.floor(Math.random() * availableFacts.length); factText.textContent = availableFacts[factIndex]; availableFacts.splice(factIndex, 1); factModal.classList.remove('hidden'); }
            function createSplash(simX, simY, strength) { splashes.push({ x: simX, y: simY, radius: 10, opacity: 1 }); ducks.forEach(duck => { if (duck.stunned > 0) return; const dx = duck.x - simX, dy = duck.y - simY, dist = Math.hypot(dx, dy); if (dist > 0.01 && dist < SPLASH_EFFECT_RADIUS) { const falloff = 1 - (dist / SPLASH_EFFECT_RADIUS); duck.vx += (dx / dist) * strength * falloff; duck.vy += (dy / dist) * strength * falloff; } }); if (fluid && !isGameOver) { const config = LEVEL_CONFIGS[level - 1]; fluid.simulate(DT / 3, NUM_ITERS / 3, OVER_RELAXATION, config.flow, performance.now() / 1000); } }
            function spawnObstacle() { const config = LEVEL_CONFIGS[level - 1]; const availableTypes = config.types; const obstacleType = availableTypes[Math.floor(Math.random() * availableTypes.length)]; obstacles.push({ id: Date.now() + Math.random(), x: -0.1 * SIM_WIDTH, y: RIVERBANK_MARGIN + (SIM_HEIGHT - 2 * RIVERBANK_MARGIN) * Math.random(), vx: 0, vy: 0, width: 0.08 + Math.random() * 0.07, height: 0.03 + Math.random() * 0.02, angle: Math.random() * Math.PI * 2, type: obstacleType }); }
            function initializeGame() { isGameOver = false; splashes = []; score = 0; levelStartTime = performance.now(); const simWidth = CANVAS_WIDTH / C_SCALE; const domainHeight = SIM_HEIGHT; const h = domainHeight / RESOLUTION; const numY = RESOLUTION; const numX = Math.floor(simWidth / h); fluid = new FluidSimulator(1000.0, numX, numY, h); ducks = []; const playerNames = ['You', 'Duck Alice', 'Duck Bob']; const playerColors = ['#FFD700', '#FF69B4', '#00BFFF']; const takenPositions = new Set(); for (let i = 0; i < NUM_PLAYERS; i++) { const startX = 0.1 * SIM_WIDTH; let startY; do { startY = RIVERBANK_MARGIN + (SIM_HEIGHT - 2 * RIVERBANK_MARGIN) * (0.1 + Math.random() * 0.8); } while (takenPositions.has(Math.floor(startY * 10))); takenPositions.add(Math.floor(startY * 10)); ducks.push({ id: i, name: playerNames[i], x: startX, y: startY, startX: startX, startY: startY, vx: 0, vy: 0, color: playerColors[i], type: i === 0 ? PlayerType.Human : PlayerType.Bot, stunned: 0 }); } obstacles = []; lastObstacleSpawnTime = performance.now(); }
            function draw() { /* ... (draw function is long and unchanged) ... */ }
            function update(currentTime) { if (isGameOver) { animationFrameId = requestAnimationFrame(update); return; } const deltaTime = (currentTime - lastFrameTime) / 1000; lastFrameTime = currentTime; const config = LEVEL_CONFIGS[level - 1]; const elapsedTimeMs = performance.now() - levelStartTime; timeDisplay.textContent = formatTime(elapsedTimeMs).slice(0, -4); scoreDisplay.textContent = score; splashes = splashes.map(s => ({ ...s, radius: s.radius + SPLASH_RADIUS_RATE * deltaTime, opacity: s.opacity - SPLASH_OPACITY_RATE * deltaTime, })).filter(s => s.opacity > 0); fluid.simulate(DT, 0, NUM_ITERS, OVER_RELAXATION, config.flow, currentTime / 1000.0); if (currentTime - lastObstacleSpawnTime > config.spawnRate && obstacles.length < config.maxObs) { spawnObstacle(); lastObstacleSpawnTime = currentTime; } ducks.forEach(duck => { if (duck.stunned > 0) { duck.stunned = Math.max(0, duck.stunned - deltaTime); duck.vx *= 0.95; duck.vy *= 0.95; } else if (duck.type === PlayerType.Bot) { /* ... (bot AI logic) ... */ } duck.vx += fluid.sampleField(duck.x, duck.y, 0, fluid.u) * FLUID_FORCE_FACTOR; duck.vy += fluid.sampleField(duck.x, duck.y, 1, fluid.v) * FLUID_FORCE_FACTOR; duck.vx *= DAMPING_FACTOR; duck.vy *= DAMPING_FACTOR; duck.x += duck.vx * DT; duck.y += duck.vy * DT; if (duck.y < RIVERBANK_MARGIN) { duck.y = RIVERBANK_MARGIN; duck.vy *= -0.5; } if (duck.y > SIM_HEIGHT - RIVERBANK_MARGIN) { duck.y = SIM_HEIGHT - RIVERBANK_MARGIN; duck.vy *= -0.5; } }); obstacles = obstacles.filter(obs => obs.x < SIM_WIDTH * 1.1); obstacles.forEach(obs => { obs.vx += fluid.sampleField(obs.x, obs.y, 0, fluid.u) * OBSTACLE_FLUID_FORCE_FACTOR; obs.vy += fluid.sampleField(obs.x, obs.y, 1, fluid.v) * OBSTACLE_FLUID_FORCE_FACTOR; obs.vx *= 0.99; obs.vy *= 0.99; obs.x += obs.vx * DT; obs.y += obs.vy * DT; }); for (const duck of ducks) for (const obs of obstacles) if (Math.hypot(duck.x - obs.x, duck.y - obs.y) < (DUCK_SIZE / C_SCALE + obs.width / 2)) { if (obs.type === ObstacleType.Log) { duck.stunned = STUN_DURATION; duck.vx *= -0.5; } else if (obs.type === ObstacleType.Garbage) { duck.x = duck.startX; duck.y = duck.startY; duck.vx = 0; duck.vy = 0; duck.stunned = STUN_DURATION; } } const winnerDuck = ducks.find(d => d.x / SIM_WIDTH >= FINISH_LINE_X); if (winnerDuck) { handleGameEnd(winnerDuck.name); return; } draw(); animationFrameId = requestAnimationFrame(update); }
            function handleGameEnd(winnerName) { isGameOver = true; winner = winnerName; const levelTime = performance.now() - levelStartTime; totalTimeMs += levelTime; if (winnerName === 'You' && level < MAX_LEVEL) { currentGameState = GameState.LevelComplete; updateUI(levelTime / 1000); } else if (winnerName === 'You' && level === MAX_LEVEL) { currentGameState = GameState.FinalWin; finalCompletionTimeMs = Math.round(totalTimeMs); finalTimeDisplay.textContent = formatTime(finalCompletionTimeMs); updateUI(); } else { currentGameState = GameState.GameOver; updateUI(totalTimeMs / 1000); } }
            function updateUI(finalTimeInSeconds = 0) { Object.values(screens).forEach(s => s.classList.add('hidden')); const mainOverlay = document.getElementById('main-overlay'); mainOverlay.style.backdropFilter = 'blur(4px)'; switch (currentGameState) { case GameState.StartScreen: screens.start.classList.remove('hidden'); mainOverlay.style.backdropFilter = 'blur(8px)'; break; case GameState.LevelComplete: screens.levelComplete.classList.remove('hidden'); levelCompleteTitle.textContent = t('levelComplete', level); levelCompleteStats.textContent = `Time: ${formatTime(finalTimeInSeconds * 1000)} | Score: ${score}`; const nextLevel = level + 1; levelCompleteDesc.textContent = t('nextLevelDesc')[nextLevel] || ""; nextLevelButton.textContent = t('nextLevelButton', nextLevel); break; case GameState.GameOver: screens.gameOver.classList.remove('hidden'); gameOverStats.textContent = `Final Time: ${formatTime(finalTimeInSeconds * 1000)} | Final Score: ${score}`; gameOverText.textContent = winner?.startsWith('Duck') ? t('gameOverBotWon', winner) : t('gameOverLost'); break; case GameState.FinalWin: screens.finalWin.classList.remove('hidden'); break; case GameState.Playing: screens.canvasContainer.classList.remove('hidden'); const config = LEVEL_CONFIGS[level - 1]; levelDisplay.textContent = `Level ${config.level}: ${config.name}`; break; } }
            function startGameFlow() { currentGameState = GameState.Playing; updateUI(); initializeGame(); lastFrameTime = performance.now(); if(animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = requestAnimationFrame(update); }
            function startGame() { level = 1; totalTimeMs = 0; availableFacts = [...(facts[currentLang] || facts.en)]; startGameFlow(); };
            const restartGame = () => { showRandomFact(); startGame(); };
            const startNextLevel = () => { level++; startGameFlow(); };

            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartGame);
            nextLevelButton.addEventListener('click', startNextLevel);
            closeAndSaveButton.addEventListener('click', () => { window.parent.postMessage({ type: 'gameTime', completion_time_ms: finalCompletionTimeMs }, '*'); });
            canvas.addEventListener('click', (e) => { if (currentGameState !== GameState.Playing) return; const rect = canvas.getBoundingClientRect(); const scaleX = CANVAS_WIDTH / rect.width, scaleY = CANVAS_HEIGHT / rect.height; const simX = (e.clientX - rect.left) * scaleX / C_SCALE, simY = (e.clientY - rect.top) * scaleY / C_SCALE; const clickedObstacleIdx = obstacles.findIndex(obs => Math.hypot(simX - obs.x, simY - obs.y) < obs.width / 2); if (clickedObstacleIdx !== -1) { const clickedObstacle = obstacles[clickedObstacleIdx]; if (clickedObstacle.type === ObstacleType.Garbage) score += SCORE_PER_GARBAGE; obstacles.splice(clickedObstacleIdx, 1); return; } createSplash(simX, simY, SPLASH_STRENGTH); });
            document.querySelectorAll('.lang-btn').forEach(button => { button.addEventListener('click', () => { currentLang = button.dataset.lang; document.querySelector('.lang-btn.active').classList.remove('active'); button.classList.add('active'); updateAllTexts(); availableFacts = [...(facts[currentLang] || facts.en)]; }); });
            document.getElementById('learn-button').addEventListener('click', () => learnModal.classList.remove('hidden'));
            document.getElementById('close-learn-modal').addEventListener('click', () => learnModal.classList.add('hidden'));
            closeFactModal.addEventListener('click', () => factModal.classList.add('hidden'));
            
            canvas.width = CANVAS_WIDTH; canvas.height = CANVAS_HEIGHT;
            gameUi.style.width = `${CANVAS_WIDTH}px`;
            document.querySelector('.lang-btn[data-lang="en"]').classList.add('active');
            updateAllTexts();
            updateUI();
        });
    </script>
</body>
</html>
