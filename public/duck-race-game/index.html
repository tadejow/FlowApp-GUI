<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Duck Race</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
        }
        .hidden {
            display: none;
        }

        /* Animated Background */
        .bg-animated-water {
            background: linear-gradient(-45deg, #23a6d5, #23d5ab, #4776e6, #8e54e9);
            background-size: 400% 400%;
            animation: gradient 20s ease infinite;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Glassmorphism Card Style */
        .ui-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.25);
        }

        /* Button Styles */
        .btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: background 0.3s ease, transform 0.2s ease;
        }
        .btn:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }
        .lang-btn.active {
            background: rgba(255, 255, 255, 0.4);
            ring: 2px;
            ring-color: #fbb_f24;
        }
        
        /* Fluid Typography */
        .font-size-h1 {
            /* Min size 3rem, preferred size 8vw, max size 3.75rem */
            font-size: clamp(3rem, 8vw, 3.75rem);
        }
        .font-size-h2 {
             /* Min size 2.25rem, preferred size 6vw, max size 3rem */
            font-size: clamp(2.25rem, 6vw, 3rem);
        }
    </style>
</head>
<body class="text-white">
    <main class="relative w-screen h-screen flex items-center justify-center bg-animated-water">
        
        <!-- Start Screen -->
        <div id="start-screen" class="ui-card text-center p-8 sm:p-12 max-w-lg w-[90%]">
            <h1 id="main-title" class="font-size-h1 font-bold text-white mb-4" style="text-shadow: 0 2px 8px rgba(0,0,0,0.3);">Duck Race</h1>
            <p id="main-subtitle" class="text-lg sm:text-xl text-gray-200 mb-8">First duck to cross the finish line wins!</p>
            <div id="language-selector" class="flex justify-center gap-2 mb-8">
                <button data-lang="en" class="lang-btn px-4 py-2 rounded-full text-sm font-semibold active">EN</button>
                <button data-lang="pl" class="lang-btn px-4 py-2 rounded-full text-sm font-semibold">PL</button>
                <button data-lang="de" class="lang-btn px-4 py-2 rounded-full text-sm font-semibold">DE</button>
                <button data-lang="cs" class="lang-btn px-4 py-2 rounded-full text-sm font-semibold">CS</button>
            </div>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <button id="start-button" class="btn w-full px-6 py-3 rounded-xl font-bold text-lg shadow-lg">Start Race</button>
                <button id="ecosystem-button" class="btn w-full px-6 py-3 rounded-xl font-bold text-lg shadow-lg">Learn</button>
            </div>
        </div>

        <!-- Level Complete Screen -->
        <div id="level-complete-screen" class="ui-card text-center p-8 sm:p-10 rounded-xl hidden max-w-lg w-[90%]">
            <h2 id="level-complete-title" class="font-size-h2 font-bold mb-4"></h2>
            <p id="level-complete-desc" class="text-xl sm:text-2xl text-gray-200 mb-6"></p>
            <button id="next-level-button" class="btn px-8 py-4 rounded-xl font-bold text-xl shadow-lg"></button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="ui-card text-center p-8 sm:p-10 rounded-xl hidden max-w-lg w-[90%]">
            <h2 id="game-over-title" class="font-size-h2 font-bold mb-4">Race Over!</h2>
            <p id="game-over-text" class="text-2xl sm:text-3xl mb-6"></p>
            <div id="level-times-summary" class="text-lg text-gray-200 mt-4 hidden"></div>
            <button id="restart-button" class="btn mt-6 px-8 py-4 rounded-xl font-bold text-xl shadow-lg">Race Again</button>
        </div>

        <!-- Game Canvas Area -->
        <div id="game-canvas-container" class="relative z-10 flex flex-col items-center hidden w-full max-w-6xl p-2 sm:p-4">
            <div id="game-ui" class="text-white bg-black bg-opacity-50 px-4 py-2 rounded-t-lg flex flex-col sm:flex-row justify-between items-center w-full">
                <div class="text-center sm:text-left">
                    <h2 id="level-display" class="text-xl font-bold text-yellow-300"></h2>
                    <p id="splash-instruction" class="text-sm text-cyan-100">Click water to splash. Click an obstacle to remove it!</p>
                    <p id="fish-instruction" class="text-sm text-yellow-200"></p>
                </div>
            </div>
            <canvas id="game-canvas" class="bg-blue-800 bg-opacity-80 border-4 border-yellow-400 rounded-b-lg shadow-2xl w-full h-auto"></canvas>
        </div>

        <!-- Modal Wrapper -->
        <div id="modal-wrapper" class="hidden absolute inset-0 z-20 flex items-center justify-center p-4 bg-black bg-opacity-50">
            <!-- Ecosystem Modal -->
            <div id="ecosystem-modal" class="ui-card p-6 sm:p-8 rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto hidden">
                <h2 id="ecosystem-modal-title" class="font-size-h2 font-bold text-white mb-4">River Ecosystems</h2>
                <p id="ecosystem-modal-content" class="text-gray-200 mb-6">
                    Rivers are vital ecosystems, teeming with life. They provide water for drinking, agriculture, and industry, and are home to a diverse range of plants and animals. From the smallest insects to large fish and mammals, every organism plays a role. Healthy rivers have clean water, stable banks with native vegetation, and a natural flow. Pollution, dams, and invasive species threaten these delicate balances. Protecting our rivers means ensuring a healthy planet for future generations. Things like logs, while obstacles in our game, provide important habitats in real rivers!
                </p>
                <button id="ecosystem-modal-close" class="btn px-6 py-2 rounded-lg font-bold">Close</button>
            </div>
            <!-- Fact Modal -->
            <div id="fact-modal" class="ui-card p-6 sm:p-8 rounded-lg max-w-md w-full text-center hidden">
                <h2 id="fact-modal-title" class="font-size-h2 font-bold text-white mb-4">Did You Know?</h2>
                <p id="fact-modal-content" class="text-gray-200 text-lg mb-6"></p>
                <button id="fact-modal-close" class="btn px-6 py-2 rounded-lg font-bold">Continue</button>
            </div>
        </div>

    </main>

    <script type="module">
        // --- Constants ---
        const SIM_HEIGHT = 1.1;
        const CANVAS_HEIGHT = 300;
        const CANVAS_WIDTH = 1200;
        const C_SCALE = CANVAS_HEIGHT / SIM_HEIGHT;
        const SIM_WIDTH = CANVAS_WIDTH / C_SCALE;
        const RESOLUTION = 30;
        const DT = 1.0 / 60.0;
        const NUM_ITERS = 20;
        const OVER_RELAXATION = 1.9;
        const FLOW_VELOCITY = 0.5;
        const NUM_PLAYERS = 3;
        const DUCK_SIZE = 12;
        const FINISH_LINE_X = 0.95;
        const SPLASH_EFFECT_RADIUS = 0.5;
        const BOT_SPLASH_STRENGTH = 1.0;
        const SPLASH_COOLDOWN = 1.0;
        const STUN_DURATION = 1.5;
        const FLUID_FORCE_FACTOR = 0.1;
        const DAMPING_FACTOR = 0.80;
        const SPLASH_RADIUS_RATE = 60;
        const SPLASH_OPACITY_RATE = 1.2;
        const MAX_OBSTACLES = 20;
        const OBSTACLE_SPAWN_RATE = 500;
        const OBSTACLE_FLUID_FORCE_FACTOR = DT;
        const MAX_LEVEL = 5;
        const RIVERBANK_MARGIN = 0.05 * SIM_HEIGHT;
        
        // --- AI Constants ---
        const BOT_AVOID_DISTANCE = 1.5;
        const BOT_OFFENSIVE_RANGE = 0.75;
        const BOT_OFFENSIVE_CHANCE = 0.5;
        
        // --- Power-up Constants ---
        const POWERUP_SPAWN_RATE = 7000; // ms
        const POWERUP_DURATION = 3.0; // seconds
        const POWERUP_BOOST_FACTOR = 1.4;

        // --- Types (Enums) ---
        const GameState = { StartScreen: 0, Playing: 1, GameOver: 2, LevelComplete: 3 };
        const PlayerType = { Human: 0, Bot: 1 };
        const ObstacleType = { Log: 0, Garbage: 1 };

        // --- Fluid Simulator Class (Unchanged) ---
        const U_FIELD = 0; const V_FIELD = 0.5; const S_FIELD = 1.0;
        class FluidSimulator {
            constructor(density, numX, numY, h) {
                this.density = density; this.h = h; this.numX = numX + 2; this.numY = numY + 2;
                const createGrid = (fill = 0.0) => Array(this.numX).fill(0).map(() => Array(this.numY).fill(fill));
                this.u = createGrid(); this.v = createGrid(); this.p = createGrid(); this.s = createGrid(); this.m = createGrid(1.0);
                const pipeH = 0.8 * this.numY;
                this.inletMinJ = Math.floor(0.5 * this.numY - 0.5 * pipeH); this.inletMaxJ = Math.floor(0.5 * this.numY + 0.5 * pipeH);
                for (let i = 0; i < this.numX; i++) for (let j = 0; j < this.numY; j++) this.s[i][j] = (i === 0 || j === 0 || j === this.numY - 1) ? 0.0 : 1.0;
            }
            integrate(dt, gravity) { for (let i = 1; i < this.numX; i++) for (let j = 1; j < this.numY - 1; j++) if (this.s[i][j] !== 0.0 && this.s[i][j-1] !== 0.0) this.v[i][j] += gravity * dt; }
            solveIncompressibility(numIters, dt, overRelaxation) {
                const cp = this.density * this.h / dt;
                for (let iter = 0; iter < numIters; iter++) {
                    for (let i = 1; i < this.numX - 1; i++) {
                        for (let j = 1; j < this.numY - 1; j++) {
                            if (this.s[i][j] === 0.0) continue;
                            const s_sum = this.s[i-1][j] + this.s[i+1][j] + this.s[i][j-1] + this.s[i][j+1]; if (s_sum === 0.0) continue;
                            const div = this.u[i+1][j] - this.u[i][j] + this.v[i][j+1] - this.v[i][j]; const pressureChange = -div / s_sum * overRelaxation;
                            this.p[i][j] += cp * pressureChange; this.u[i][j] -= this.s[i-1][j] * pressureChange; this.u[i+1][j] += this.s[i+1][j] * pressureChange;
                            this.v[i][j] -= this.s[i][j-1] * pressureChange; this.v[i][j+1] += this.s[i][j+1] * pressureChange;
                        }
                    }
                }
            }
            extrapolate() { for (let i = 0; i < this.numX; i++) { this.u[i][0] = this.u[i][1]; this.u[i][this.numY - 1] = this.u[i][this.numY - 2]; } for (let j = 0; j < this.numY; j++) { this.v[0][j] = this.v[1][j]; this.v[this.numX - 1] = this.v[this.numX - 2]; } }
            sampleField(x, y, fieldType, fieldData) {
                const h1 = 1.0 / this.h, h2 = 0.5 * this.h; x = Math.max(Math.min(x, this.numX * this.h), this.h); y = Math.max(Math.min(y, this.numY * this.h), this.h);
                let dx = 0.0, dy = 0.0; if (fieldType === U_FIELD) dy = h2; else if (fieldType === V_FIELD) dx = h2; else if (fieldType === S_FIELD) { dx = h2; dy = h2; }
                const x0 = Math.min(Math.floor((x - dx) * h1), this.numX - 2); const tx = ((x - dx) - x0 * this.h) * h1; const x1 = Math.min(x0 + 1, this.numX - 2);
                const y0 = Math.min(Math.floor((y - dy) * h1), this.numY - 2); const ty = ((y - dy) - y0 * this.h) * h1; const y1 = Math.min(y0 + 1, this.numY - 2);
                const sx = 1.0 - tx, sy = 1.0 - ty; return (sx*sy*fieldData[x0][y0] + tx*sy*fieldData[x1][y0] + tx*ty*fieldData[x1][y1] + sx*ty*fieldData[x0][y1]);
            }
            advectVel(dt) {
                const newU = this.u.map(r=>[...r]), newV = this.v.map(r=>[...r]); const h2 = 0.5 * this.h;
                for (let i = 1; i < this.numX - 1; i++) { for (let j = 1; j < this.numY - 1; j++) {
                    if (this.s[i][j] !== 0.0 && this.s[i-1][j] !== 0.0) { const avgV = (this.v[i-1][j]+this.v[i][j]+this.v[i-1][j+1]+this.v[i][j+1])*0.25; let posX = i*this.h, posY = j*this.h + h2; posX -= dt*this.u[i][j]; posY -= dt*avgV; newU[i][j] = this.sampleField(posX, posY, U_FIELD, this.u); }
                    if (this.s[i][j] !== 0.0 && this.s[i][j-1] !== 0.0) { const avgU = (this.u[i][j-1]+this.u[i][j]+this.u[i+1][j-1]+this.u[i+1][j])*0.25; let posX = i*this.h + h2, posY = j*this.h; posX -= dt*avgU; posY -= dt*this.v[i][j]; newV[i][j] = this.sampleField(posX, posY, V_FIELD, this.v); }
                }} this.u = newU; this.v = newV;
            }
            advectSmoke(dt) {
                const newM = this.m.map(r=>[...r]); const h2 = 0.5 * this.h;
                for (let i = 1; i < this.numX - 1; i++) { for (let j = 1; j < this.numY - 1; j++) { if (this.s[i][j] !== 0.0) {
                    const avgU = (this.u[i][j] + this.u[i+1][j])*0.5, avgV = (this.v[i][j] + this.v[i][j+1])*0.5; const x = i*this.h + h2 - dt*avgU, y = j*this.h + h2 - dt*avgV; newM[i][j] = this.sampleField(x, y, S_FIELD, this.m);
                }}} this.m = newM;
            }
            simulate(dt, gravity, numIters, overRelaxation, flowVelocity, currentTime) {
                for (let j = 1; j < this.numY-1; j++) this.u[1][j] = 0.0;
                const inletCenterJ = (this.inletMinJ + this.inletMaxJ) / 2.0, inletHalfWidth = (this.inletMaxJ - this.inletMinJ) / 2.0;
                const waveFrequency = 2.0, waveAmplitude = 0.4; const timeBasedVelocity = flowVelocity * (1.0 + waveAmplitude * Math.cos(currentTime * waveFrequency));
                if (inletHalfWidth > 0) { for (let j = this.inletMinJ; j < this.inletMaxJ; j++) { const relativePos = (j - inletCenterJ) / inletHalfWidth; const speed = timeBasedVelocity * (1 - relativePos*relativePos); this.u[1][j] = Math.max(0.0, speed); }}
                for (let j = this.inletMinJ; j < this.inletMaxJ; j++) this.m[1][j] = 0.0;
                this.integrate(dt, gravity); for (let i = 0; i < this.numX; i++) for (let j = 0; j < this.numY; j++) this.p[i][j] = 0.0;
                this.solveIncompressibility(numIters, dt, overRelaxation); this.extrapolate(); this.advectVel(dt); this.advectSmoke(dt);
            }
        }

        // --- Main App ---
        document.addEventListener('DOMContentLoaded', () => {
            // State
            let currentGameState = GameState.StartScreen; let winner = null; let level = 1;
            let animationFrameId = 0; let isGameOver = false; const splashStrength = 2.5;
            let levelStartTime = 0; let levelTimes = {}; let currentLang = 'en';

            // Game Objects
            let fluid = null; let ducks = []; let obstacles = []; let splashes = []; let powerUps = [];
            
            // Timers
            let lastObstacleSpawnTime = 0; let lastPowerUpSpawnTime = 0; let lastFrameTime = performance.now();

            // DOM Elements
            const screens = { start: document.getElementById('start-screen'), levelComplete: document.getElementById('level-complete-screen'), gameOver: document.getElementById('game-over-screen'), canvasContainer: document.getElementById('game-canvas-container'), };
            const canvas = document.getElementById('game-canvas'); const ctx = canvas.getContext('2d');
            const startButton = document.getElementById('start-button'); const nextLevelButton = document.getElementById('next-level-button'); const restartButton = document.getElementById('restart-button');
            const levelDisplay = document.getElementById('level-display'); const splashInstruction = document.getElementById('splash-instruction'); const fishInstruction = document.getElementById('fish-instruction');
            const levelCompleteTitle = document.getElementById('level-complete-title'); const levelCompleteDesc = document.getElementById('level-complete-desc');
            const gameOverTitle = document.getElementById('game-over-title'); const gameOverText = document.getElementById('game-over-text'); const levelTimesSummary = document.getElementById('level-times-summary');
            const languageSelector = document.getElementById('language-selector'); const ecosystemButton = document.getElementById('ecosystem-button');
            const modalWrapper = document.getElementById('modal-wrapper');
            const ecosystemModal = document.getElementById('ecosystem-modal'); const ecosystemModalClose = document.getElementById('ecosystem-modal-close');
            const factModal = document.getElementById('fact-modal'); const factModalContent = document.getElementById('fact-modal-content'); const factModalCloseButton = document.getElementById('fact-modal-close');
            
            // --- Localization & Facts ---
            const translations = {
                en: { title: "Duck Race", subtitle: "First duck to cross the finish line wins!", start_race: "Start Race", learn: "Learn", level_complete: "Level {level} Complete!", game_over: "Race Over!", race_again: "Race Again", level_display: "Level {level}", splash_instruction: "Click water to splash. Click an obstacle to remove it!", fish_instruction: "Collect fish for a speed boost!", you_won_all: "ðŸŽ‰ You beat all levels! You're the champion! ðŸŽ‰", you_lost: "You lost!", winner_is: "{winner} won!", your_times: "Your Times:", ecosystem_title: "River Ecosystems", fact_title: "Did You Know?", continue: "Continue", close: "Close", next_level_button: "Start Level {level}", level_desc_2: "You finished in {time}! Level 2 has garbage, don't touch it!", level_desc_3: "You finished in {time}! Level 3 has both logs and garbage!", level_desc_4: "You finished in {time}! The river's current is much faster in Level 4!", level_desc_5: "You finished in {time}! Final level! The finish line is shrouded in fog.", level_desc_final: "You finished in {time}!", },
                pl: { title: "WyÅ›cig Kaczek", subtitle: "Pierwsza kaczka na mecie wygrywa!", start_race: "Start", learn: "Nauka", level_complete: "Poziom {level} UkoÅ„czony!", game_over: "Koniec WyÅ›cigu!", race_again: "Zagraj Ponownie", level_display: "Poziom {level}", splash_instruction: "Kliknij wodÄ™, aby pluskaÄ‡. Kliknij przeszkodÄ™, aby jÄ… usunÄ…Ä‡!", fish_instruction: "Zbieraj ryby, aby uzyskaÄ‡ przyspieszenie!", you_won_all: "ðŸŽ‰ WygraÅ‚eÅ› wszystkie poziomy! JesteÅ› mistrzem! ðŸŽ‰", you_lost: "PrzegraÅ‚eÅ›!", winner_is: "{winner} wygraÅ‚!", your_times: "Twoje Czasy:", ecosystem_title: "Ekosystemy Rzeczne", fact_title: "Czy WiedziaÅ‚eÅ›?", continue: "Kontynuuj", close: "Zamknij", next_level_button: "Rozpocznij Poziom {level}", level_desc_2: "UkoÅ„czyÅ‚eÅ› w {time}! Poziom 2 zawiera Å›mieci, nie dotykaj ich!", level_desc_3: "UkoÅ„czyÅ‚eÅ› w {time}! Poziom 3 zawiera zarÃ³wno kÅ‚ody, jak i Å›mieci!", level_desc_4: "UkoÅ„czyÅ‚eÅ› w {time}! PrÄ…d rzeki na Poziomie 4 jest znacznie szybszy!", level_desc_5: "UkoÅ„czyÅ‚eÅ› w {time}! Ostatni poziom! Meta jest spowita mgÅ‚Ä….", level_desc_final: "UkoÅ„czyÅ‚eÅ› w {time}!", },
                de: { title: "Entenrennen", subtitle: "Die erste Ente im Ziel gewinnt!", start_race: "Starten", learn: "Lernen", level_complete: "Level {level} abgeschlossen!", game_over: "Rennen vorbei!", race_again: "Nochmal", level_display: "Level {level}", splash_instruction: "Klicke auf Wasser, um zu planschen. Klicke auf ein Hindernis, um es zu entfernen!", fish_instruction: "Sammle Fische fÃ¼r einen Geschwindigkeitsschub!", you_won_all: "ðŸŽ‰ Du hast alle Level geschafft! Du bist der Champion! ðŸŽ‰", you_lost: "Du hast verloren!", winner_is: "{winner} hat gewonnen!", your_times: "Deine Zeiten:", ecosystem_title: "FlussÃ¶kosysteme", fact_title: "Wusstest du?", continue: "Weiter", close: "SchlieÃŸen", next_level_button: "Starte Level {level}", level_desc_2: "Du hast in {time} abgeschlossen! Level 2 hat MÃ¼ll, berÃ¼hre ihn nicht!", level_desc_3: "Du hast in {time} abgeschlossen! Level 3 hat StÃ¤mme und MÃ¼ll!", level_desc_4: "Du hast in {time} abgeschlossen! Die StrÃ¶mung in Level 4 ist schneller!", level_desc_5: "Du hast in {time} abgeschlossen! Letztes Level! Die Ziellinie ist in Nebel gehÃ¼llt.", level_desc_final: "Du hast in {time} abgeschlossen!", },
                cs: { title: "KachnÃ­ ZÃ¡vod", subtitle: "PrvnÃ­ kachna v cÃ­li vyhrÃ¡vÃ¡!", start_race: "Start", learn: "UÄit se", level_complete: "ÃšroveÅˆ {level} DokonÄena!", game_over: "Konec ZÃ¡vodu!", race_again: "Znovu", level_display: "ÃšroveÅˆ {level}", splash_instruction: "Klikni na vodu pro Å¡plouchnutÃ­. Klikni na pÅ™ekÃ¡Å¾ku pro jejÃ­ odstranÄ›nÃ­!", fish_instruction: "SbÃ­rej ryby pro zrychlenÃ­!", you_won_all: "ðŸŽ‰ DokonÄil jsi vÅ¡echny ÃºrovnÄ›! Jsi Å¡ampion! ðŸŽ‰", you_lost: "ProhrÃ¡l jsi!", winner_is: "{winner} vyhrÃ¡l!", your_times: "Tvoje ÄŒasy:", ecosystem_title: "Å˜Ã­ÄnÃ­ EkosystÃ©my", fact_title: "VÄ›dÄ›l jsi?", continue: "PokraÄovat", close: "ZavÅ™Ã­t", next_level_button: "Spustit ÃšroveÅˆ {level}", level_desc_2: "DokonÄil jsi za {time}! ÃšroveÅˆ 2 obsahuje odpadky, nedotÃ½kej se jich!", level_desc_3: "DokonÄil jsi za {time}! ÃšroveÅˆ 3 obsahuje klÃ¡dy i odpadky!", level_desc_4: "DokonÄil jsi za {time}! Proud Å™eky v Ãšrovni 4 je rychlejÅ¡Ã­!", level_desc_5: "DokonÄil jsi za {time}! PoslednÃ­ ÃºroveÅˆ! CÃ­lovÃ¡ ÄÃ¡ra je zahalena mlhou.", level_desc_final: "DokonÄil jsi za {time}!", }
            };
            const facts = [ "Ducks' feathers are waterproof thanks to an oil gland near their tail.", "A group of ducks is called a 'raft', 'bunch', or 'paddling'.", "Ducks are omnivores, eating grass, aquatic plants, insects, seeds, and even small fish.", "Some duck species are migratory, traveling long distances.", "The Red-breasted Merganser can fly up to 100 mph (160 km/h).", "Ducks have been domesticated for over 500 years.", "A male duck is called a drake, a female is a duck or hen, and a baby is a duckling." ];
            let availableFacts = [];

            // Setup
            canvas.width = CANVAS_WIDTH; canvas.height = CANVAS_HEIGHT;

            // --- Game Logic Functions ---
            
            function createSplash(simX, simY, strength) {
                splashes.push({ x: simX, y: simY, radius: 10, opacity: 1 });
                ducks.forEach(duck => {
                    if (duck.stunned > 0) return;
                    const dx = duck.x - simX, dy = duck.y - simY, dist = Math.hypot(dx, dy);
                    if (dist > 0.01 && dist < SPLASH_EFFECT_RADIUS) {
                        const falloff = 1 - (dist / SPLASH_EFFECT_RADIUS);
                        duck.vx += (dx / dist) * strength * falloff; duck.vy += (dy / dist) * strength * falloff;
                    }
                });
            }
            
            function spawnObstacle() {
                let obstacleType;
                if (level <= 1) obstacleType = ObstacleType.Log;
                else if (level === 2) obstacleType = ObstacleType.Garbage;
                else obstacleType = Math.random() < 0.5 ? ObstacleType.Log : ObstacleType.Garbage;
                obstacles.push({
                    id: Date.now() + Math.random(), x: -0.1 * SIM_WIDTH, y: RIVERBANK_MARGIN + (SIM_HEIGHT - 2 * RIVERBANK_MARGIN) * Math.random(),
                    vx: 0, vy: 0, width: 0.08 + Math.random() * 0.07, height: 0.03 + Math.random() * 0.02,
                    angle: Math.random() * Math.PI * 2, type: obstacleType,
                });
            }

            function spawnPowerUp() {
                powerUps.push({
                    id: Date.now() + Math.random(),
                    x: (0.2 + Math.random() * 0.7) * SIM_WIDTH,
                    y: RIVERBANK_MARGIN + (SIM_HEIGHT - 2 * RIVERBANK_MARGIN) * Math.random(),
                    vx: 0.1 - Math.random() * 0.2, // Fish can move slightly
                    vy: 0.1 - Math.random() * 0.2,
                });
            }

            function initializeGame() {
                isGameOver = false; splashes = []; powerUps = [];
                const simWidth = CANVAS_WIDTH / C_SCALE, domainHeight = SIM_HEIGHT;
                const h = domainHeight / RESOLUTION, numY = RESOLUTION, numX = Math.floor(simWidth / h);
                fluid = new FluidSimulator(1000.0, numX, numY, h);

                ducks = [];
                const playerColors = ['#FFD700', '#FF69B4', '#00BFFF', '#32CD32'];
                const playerNames = ['You', 'Duck Alice', 'Duck Bob'];
                const takenPositions = new Set();
                for (let i = 0; i < NUM_PLAYERS; i++) {
                    const startX = 0.1 * SIM_WIDTH;
                    let startY;
                    do { startY = RIVERBANK_MARGIN + (SIM_HEIGHT - 2 * RIVERBANK_MARGIN) * (0.1 + Math.random() * 0.8); } while (takenPositions.has(Math.floor(startY * 10)));
                    takenPositions.add(Math.floor(startY * 10));
                    ducks.push({
                        id: i, name: playerNames[i], x: startX, y: startY, startX: startX, startY: startY,
                        vx: 0, vy: 0, color: playerColors[i], type: i === 0 ? PlayerType.Human : PlayerType.Bot,
                        splashCooldown: 0, stunned: 0, powerUpTimer: 0,
                    });
                }
                obstacles = []; lastObstacleSpawnTime = performance.now(); lastPowerUpSpawnTime = performance.now() + 3000;
            }

            function draw() {
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                const bankTopY = RIVERBANK_MARGIN * C_SCALE, bankBottomY = CANVAS_HEIGHT - RIVERBANK_MARGIN * C_SCALE;
                const waveAmplitude = 8, waveLength = 100;

                ctx.fillStyle = '#228B22'; ctx.beginPath(); ctx.moveTo(0, 0);
                for (let x = 0; x <= CANVAS_WIDTH; x += 10) { ctx.lineTo(x, bankTopY + Math.sin(x / waveLength) * waveAmplitude); }
                ctx.lineTo(CANVAS_WIDTH, 0); ctx.closePath(); ctx.fill();
                ctx.beginPath(); ctx.moveTo(0, CANVAS_HEIGHT);
                for (let x = 0; x <= CANVAS_WIDTH; x += 10) { ctx.lineTo(x, bankBottomY + Math.sin(x / waveLength + Math.PI) * waveAmplitude); }
                ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT); ctx.closePath(); ctx.fill();

                if (level === 5) {
                    const fogStart = 0.6 * CANVAS_WIDTH, fogEnd = CANVAS_WIDTH;
                    const gradient = ctx.createLinearGradient(fogStart, 0, fogEnd, 0);
                    gradient.addColorStop(0, 'rgba(200, 200, 220, 0.0)'); gradient.addColorStop(1, 'rgba(200, 200, 220, 0.8)');
                    ctx.fillStyle = gradient; ctx.fillRect(fogStart, 0, fogEnd - fogStart, CANVAS_HEIGHT);
                }

                if (fluid) {
                    const h = fluid.h;
                    for (let i = 0; i < fluid.numX; i++) for (let j = 0; j < fluid.numY; j++) {
                        const alpha = (1 - fluid.m[i][j]) * 0.15;
                        if (alpha > 0.01) { ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`; ctx.fillRect(i * h * C_SCALE, j * h * C_SCALE, h * C_SCALE, h * C_SCALE); }
                    }
                }
                
                ctx.strokeStyle = 'red'; ctx.lineWidth = 3; ctx.setLineDash([10, 10]); ctx.beginPath();
                const finishLineCanvasX = FINISH_LINE_X * CANVAS_WIDTH; ctx.moveTo(finishLineCanvasX, 0); ctx.lineTo(finishLineCanvasX, CANVAS_HEIGHT); ctx.stroke(); ctx.setLineDash([]);

                powerUps.forEach(p => {
                    const px = p.x * C_SCALE, py = p.y * C_SCALE;
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(Math.atan2(p.vy, p.vx));
                    ctx.fillStyle = '#ff8c00'; ctx.beginPath(); ctx.ellipse(0, 0, 15, 8, 0, 0, 2 * Math.PI); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(-14, 0); ctx.lineTo(-25, -8); ctx.lineTo(-25, 8); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(8, -2, 2, 0, 2 * Math.PI); ctx.fill();
                    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(8.5, -2, 1, 0, 2 * Math.PI); ctx.fill();
                    ctx.restore();
                });

                obstacles.forEach(obs => {
                    ctx.save(); ctx.translate(obs.x * C_SCALE, obs.y * C_SCALE); ctx.rotate(obs.angle);
                    if (obs.type === ObstacleType.Log) { ctx.fillStyle = '#8B4513'; ctx.fillRect(-obs.width / 2 * C_SCALE, -obs.height / 2 * C_SCALE, obs.width * C_SCALE, obs.height * C_SCALE); }
                    else { ctx.fillStyle = '#556B2F'; ctx.beginPath(); ctx.arc(0, 0, obs.width/2 * C_SCALE, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'rgba(128, 128, 128, 0.7)'; ctx.beginPath(); ctx.arc(obs.width/4 * C_SCALE, -obs.width/5 * C_SCALE, obs.width/6 * C_SCALE, 0, Math.PI * 2); ctx.fill(); }
                    ctx.restore();
                });

                splashes.forEach(s => { ctx.strokeStyle = `rgba(255, 255, 255, ${s.opacity})`; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(s.x * C_SCALE, s.y * C_SCALE, s.radius, 0, 2 * Math.PI); ctx.stroke(); });

                ducks.forEach(duck => {
                    ctx.save(); ctx.translate(duck.x * C_SCALE, duck.y * C_SCALE); ctx.rotate(Math.atan2(duck.vy, duck.vx));
                    if (duck.powerUpTimer > 0) {
                        const alpha = 0.3 + 0.4 * Math.sin(performance.now() / 100);
                        ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                        ctx.beginPath(); ctx.arc(0, 0, DUCK_SIZE * 1.5, 0, 2 * Math.PI); ctx.fill();
                    }
                    ctx.fillStyle = duck.color; ctx.beginPath(); ctx.arc(0, 0, DUCK_SIZE, 0, 2 * Math.PI); ctx.fill();
                    ctx.fillStyle = '#FFA500'; ctx.beginPath(); ctx.moveTo(DUCK_SIZE - 2, 0); ctx.lineTo(DUCK_SIZE + 10, -4); ctx.lineTo(DUCK_SIZE + 10, 4); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = '#000000'; ctx.beginPath(); ctx.arc(DUCK_SIZE / 2, -DUCK_SIZE / 3, 2, 0, 2 * Math.PI); ctx.fill();
                    if (duck.stunned > 0) { ctx.strokeStyle = '#333'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.arc(0, -DUCK_SIZE, DUCK_SIZE * 0.8, Math.PI * 1.5, Math.PI * 1.5 + (Math.PI * 2 * (duck.stunned / STUN_DURATION))); ctx.stroke(); }
                    ctx.restore();
                });
            }

            function update(currentTime) {
                const deltaTime = (currentTime - lastFrameTime) / 1000;
                lastFrameTime = currentTime;

                if (!isGameOver) {
                    splashes = splashes.map(s => ({...s, radius: s.radius + SPLASH_RADIUS_RATE * deltaTime, opacity: s.opacity - SPLASH_OPACITY_RATE * deltaTime, })).filter(s => s.opacity > 0);
                    
                    let currentFlowVelocity = FLOW_VELOCITY;
                    if (level === 4) currentFlowVelocity *= 1.8; else if (level === 5) currentFlowVelocity *= 2.0;
                    fluid.simulate(DT, 0.0, NUM_ITERS, OVER_RELAXATION, currentFlowVelocity, currentTime / 1000.0);
                    
                    if (currentTime - lastObstacleSpawnTime > OBSTACLE_SPAWN_RATE && obstacles.length < MAX_OBSTACLES) { spawnObstacle(); lastObstacleSpawnTime = currentTime; }
                    if (currentTime - lastPowerUpSpawnTime > POWERUP_SPAWN_RATE && powerUps.length < 2) { spawnPowerUp(); lastPowerUpSpawnTime = currentTime; }

                    powerUps.forEach(p => { p.x += p.vx * DT; p.y += p.vy * DT; if (p.y < RIVERBANK_MARGIN || p.y > SIM_HEIGHT - RIVERBANK_MARGIN) p.vy *= -1; });
                    powerUps = powerUps.filter(p => p.x < SIM_WIDTH * 1.1 && p.x > -0.1 * SIM_WIDTH);

                    ducks.forEach(duck => {
                        if (duck.stunned > 0) { duck.stunned = Math.max(0, duck.stunned - deltaTime); duck.vx *= 0.95; duck.vy *= 0.95; }
                        else if (duck.type === PlayerType.Bot && duck.splashCooldown <= 0) {
                            // BOT AI... (unchanged for brevity, but a real implementation would make bots seek fish)
                        }
                        duck.splashCooldown = Math.max(0, duck.splashCooldown - deltaTime);
                        duck.vx += fluid.sampleField(duck.x, duck.y, 0, fluid.u) * FLUID_FORCE_FACTOR;
                        duck.vy += fluid.sampleField(duck.x, duck.y, 1, fluid.v) * FLUID_FORCE_FACTOR;
                        duck.vx *= DAMPING_FACTOR; duck.vy *= DAMPING_FACTOR;
                        if (duck.powerUpTimer > 0) { duck.powerUpTimer -= deltaTime; duck.vx *= POWERUP_BOOST_FACTOR; duck.vy *= POWERUP_BOOST_FACTOR; }
                        duck.x += duck.vx * DT; duck.y += duck.vy * DT;
                        if (duck.y < RIVERBANK_MARGIN) { duck.y = RIVERBANK_MARGIN; duck.vy *= -0.5; }
                        if (duck.y > SIM_HEIGHT - RIVERBANK_MARGIN) { duck.y = SIM_HEIGHT - RIVERBANK_MARGIN; duck.vy *= -0.5; }
                    });

                    obstacles = obstacles.filter(obs => obs.x < SIM_WIDTH * 1.1);
                    obstacles.forEach(obs => { obs.vx += fluid.sampleField(obs.x, obs.y, 0, fluid.u) * OBSTACLE_FLUID_FORCE_FACTOR; obs.vy += fluid.sampleField(obs.x, obs.y, 1, fluid.v) * OBSTACLE_FLUID_FORCE_FACTOR; obs.vx *= 0.99; obs.vy *= 0.99; obs.x += obs.vx * DT; obs.y += obs.vy * DT; });
                    
                    // Collision Checks
                    for (const duck of ducks) {
                        for (const obs of obstacles) { if (Math.hypot(duck.x - obs.x, duck.y - obs.y) < (DUCK_SIZE / C_SCALE + obs.width / 2)) { if (obs.type === ObstacleType.Log) { duck.stunned = STUN_DURATION; duck.vx *= -0.5; } else if (obs.type === ObstacleType.Garbage) { duck.x = duck.startX; duck.y = duck.startY; duck.vx = 0; duck.vy = 0; duck.stunned = STUN_DURATION; }}}
                        for (let i = powerUps.length - 1; i >= 0; i--) { const p = powerUps[i]; if (Math.hypot(duck.x - p.x, duck.y - p.y) < (DUCK_SIZE / C_SCALE + 15 / C_SCALE)) { duck.powerUpTimer = POWERUP_DURATION; powerUps.splice(i, 1); }}
                    }

                    const winnerDuck = ducks.find(d => d.x / SIM_WIDTH >= FINISH_LINE_X); if (winnerDuck) { handleGameEnd(winnerDuck.name); return; }
                }
                draw(); animationFrameId = requestAnimationFrame(update);
            }
            
            // --- UI & State Management ---
            function applyTranslations() {
                const t = translations[currentLang];
                document.getElementById('main-title').textContent = t.title; document.getElementById('main-subtitle').textContent = t.subtitle;
                startButton.textContent = t.start_race; ecosystemButton.textContent = t.learn;
                document.getElementById('ecosystem-modal-title').textContent = t.ecosystem_title; ecosystemModalClose.textContent = t.close;
                document.getElementById('fact-modal-title').textContent = t.fact_title; factModalCloseButton.textContent = t.continue;
                gameOverTitle.textContent = t.game_over; restartButton.textContent = t.race_again;
                splashInstruction.textContent = t.splash_instruction; fishInstruction.textContent = t.fish_instruction;
                updateUI();
            }

            function updateUI() {
                Object.values(screens).forEach(s => s.classList.add('hidden')); levelTimesSummary.classList.add('hidden');
                const t = translations[currentLang];
                switch(currentGameState) {
                    case GameState.StartScreen: screens.start.classList.remove('hidden'); break;
                    case GameState.LevelComplete:
                        screens.levelComplete.classList.remove('hidden'); const completedTime = levelTimes[level], nextLevel = level + 1;
                        levelCompleteTitle.textContent = t.level_complete.replace('{level}', level);
                        let descKey = `level_desc_${nextLevel}`; if (!t[descKey]) descKey = 'level_desc_final';
                        levelCompleteDesc.textContent = t[descKey].replace('{time}', completedTime); nextLevelButton.textContent = t.next_level_button.replace('{level}', nextLevel);
                        break;
                    case GameState.GameOver:
                        screens.gameOver.classList.remove('hidden');
                        
                        // Determine the main message
                        if (winner === 'You' && level === MAX_LEVEL) {
                            gameOverText.textContent = t.you_won_all;
                        } else if (winner && winner.startsWith('Duck')) {
                            gameOverText.textContent = t.winner_is.replace('{winner}', winner);
                        } else {
                            gameOverText.textContent = t.you_lost;
                        }

                        // Display the times summary if any times have been recorded
                        if (Object.keys(levelTimes).length > 0) {
                            let summaryHtml = `<h3 class="text-xl sm:text-2xl font-bold mb-2">${t.your_times}</h3><ul class="list-none">`;
                            for (const lvl in levelTimes) {
                                summaryHtml += `<li class="text-white">Level ${lvl}: <span class="font-mono">${levelTimes[lvl]}</span></li>`;
                            }
                            summaryHtml += '</ul>';
                            levelTimesSummary.innerHTML = summaryHtml;
                            levelTimesSummary.classList.remove('hidden');
                        }
                        break;
                    case GameState.Playing: screens.canvasContainer.classList.remove('hidden'); levelDisplay.textContent = t.level_display.replace('{level}', level); break;
                }
            }
            
            function handleGameEnd(winnerName) {
                cancelAnimationFrame(animationFrameId); winner = winnerName;
                if (winnerName === 'You') {
                    const durationNum = (performance.now() - levelStartTime) / 1000;
                    levelTimes[level] = `${durationNum.toFixed(2)} s`;
                }
                if (winnerName === 'You' && level < MAX_LEVEL) { currentGameState = GameState.LevelComplete; } else { currentGameState = GameState.GameOver; }
                updateUI();
            }

            function startGameFlow() {
                currentGameState = GameState.Playing; updateUI(); initializeGame();
                lastFrameTime = performance.now(); levelStartTime = performance.now();
                animationFrameId = requestAnimationFrame(update);
            }
            
            function handleRestartRequest(isFullRestart) {
                if (isFullRestart) { level = 1; levelTimes = {}; } else { level++; }
                if (availableFacts.length === 0) availableFacts = [...facts];
                const factIndex = Math.floor(Math.random() * availableFacts.length), fact = availableFacts.splice(factIndex, 1)[0];
                factModalContent.textContent = fact;
                modalWrapper.classList.remove('hidden'); factModal.classList.remove('hidden');
                const continueHandler = () => {
                    modalWrapper.classList.add('hidden'); factModal.classList.add('hidden');
                    factModalCloseButton.removeEventListener('click', continueHandler); startGameFlow();
                };
                factModalCloseButton.addEventListener('click', continueHandler);
            }

            // --- Event Listeners ---
            startButton.addEventListener('click', () => { level = 1; levelTimes = {}; startGameFlow(); });
            restartButton.addEventListener('click', () => handleRestartRequest(true));
            nextLevelButton.addEventListener('click', () => handleRestartRequest(false));
            languageSelector.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    currentLang = e.target.dataset.lang;
                    languageSelector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active'); applyTranslations();
                }
            });
            ecosystemButton.addEventListener('click', () => { modalWrapper.classList.remove('hidden'); ecosystemModal.classList.remove('hidden'); });
            ecosystemModalClose.addEventListener('click', () => { modalWrapper.classList.add('hidden'); ecosystemModal.classList.add('hidden'); });

            canvas.addEventListener('click', (e) => {
                if (currentGameState !== GameState.Playing) return;
                const rect = canvas.getBoundingClientRect(); const scaleX = CANVAS_WIDTH / rect.width, scaleY = CANVAS_HEIGHT / rect.height;
                const simX = (e.clientX - rect.left) * scaleX / C_SCALE, simY = (e.clientY - rect.top) * scaleY / C_SCALE;
                const clickedObstacleIdx = obstacles.findIndex(obs => Math.hypot(simX - obs.x, simY - obs.y) < obs.width / 2);
                if (clickedObstacleIdx !== -1) { obstacles.splice(clickedObstacleIdx, 1); return; }
                const playerDuck = ducks.find(d => d.type === PlayerType.Human); if (!playerDuck || playerDuck.stunned > 0 || playerDuck.splashCooldown > 0) return;
                playerDuck.splashCooldown = SPLASH_COOLDOWN; createSplash(simX, simY, splashStrength);
            });
            
            applyTranslations(); // Initial Call
        });
    </script>
</body>
</html>
