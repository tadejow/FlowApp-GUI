<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Duck Race - Pure HTML</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            /* A fun, bubbly font that fits the game's theme */
            font-family: 'Comic Sans MS', cursive, sans-serif;
            overflow: hidden; /* Prevent scrollbars */
        }
        .accent-yellow-400 {
            accent-color: #FBBF24;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-900">
    <main class="relative w-screen h-screen flex items-center justify-center bg-cover bg-center" style="background-image: url('https://picsum.photos/1920/1080?blur=5')">
        <div class="absolute inset-0 bg-blue-900 bg-opacity-40 backdrop-blur-sm"></div>

        <!-- Start Screen -->
        <div id="start-screen" class="relative z-10 text-center">
            <h1 class="text-6xl font-bold text-yellow-300 mb-4">Duck Race</h1>
            <p class="text-xl text-cyan-200 mb-8">First duck to cross the finish line wins!</p>
            <button id="start-button" class="px-8 py-4 bg-yellow-400 text-gray-900 font-bold rounded-lg shadow-lg hover:bg-yellow-500 transition-transform transform hover:scale-105">
                Start Race
            </button>
        </div>

        <!-- Level Complete Screen -->
        <div id="level-complete-screen" class="relative z-10 text-center bg-black bg-opacity-70 p-10 rounded-xl hidden">
            <h2 id="level-complete-title" class="text-5xl font-bold text-yellow-300 mb-4"></h2>
            <p id="level-complete-desc" class="text-2xl text-white mb-6"></p>
            <button id="next-level-button" class="px-8 py-4 bg-green-500 text-white font-bold rounded-lg shadow-lg hover:bg-green-600 transition-transform transform hover:scale-105">
            </button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="relative z-10 text-center bg-black bg-opacity-70 p-10 rounded-xl hidden">
            <h2 class="text-5xl font-bold text-yellow-300 mb-4">Race Over!</h2>
            <p id="game-over-text" class="text-3xl text-white mb-6"></p>
            <button id="restart-button" class="px-8 py-4 bg-yellow-400 text-gray-900 font-bold rounded-lg shadow-lg hover:bg-yellow-500 transition-transform transform hover:scale-105">
                Race Again
            </button>
        </div>

        <!-- Game Canvas Area -->
        <div id="game-canvas-container" class="relative z-10 flex flex-col items-center hidden">
            <div id="game-ui" class="text-white bg-black bg-opacity-50 px-4 py-2 rounded-t-lg flex justify-between items-center">
                <div>
                    <h2 id="level-display" class="text-xl font-bold text-yellow-300"></h2>
                    <p class="text-sm text-cyan-100">Click the water to splash. Click an obstacle to remove it!</p>
                </div>
                <div class="flex flex-col items-center text-white ml-4">
                    <label for="splashStrength" class="text-sm font-bold text-yellow-300 mb-1">
                        Splash Strength: <span id="splash-strength-value" class="font-mono w-8 inline-block text-right">1.0</span>
                    </label>
                    <input id="splashStrength" type="range" min="0.2" max="2.5" step="0.1" value="1.0" class="w-48 cursor-pointer accent-yellow-400" aria-label="Adjust splash strength" />
                </div>
            </div>
            <canvas id="game-canvas" class="bg-blue-800 bg-opacity-80 border-4 border-yellow-400 rounded-b-lg shadow-2xl"></canvas>
        </div>
    </main>

    <script type="module">
        // --- Constants ---
        const SIM_HEIGHT = 1.1;
        const CANVAS_HEIGHT = 300;
        const CANVAS_WIDTH = 1200;
        const C_SCALE = CANVAS_HEIGHT / SIM_HEIGHT;
        const SIM_WIDTH = CANVAS_WIDTH / C_SCALE;
        const RESOLUTION = 30;
        const DT = 1.0 / 60.0;
        const NUM_ITERS = 20;
        const OVER_RELAXATION = 1.9;
        const FLOW_VELOCITY = 0.5;
        const NUM_PLAYERS = 3;
        const DUCK_SIZE = 12;
        const FINISH_LINE_X = 0.95;
        const SPLASH_EFFECT_RADIUS = 0.5;
        const BOT_SPLASH_STRENGTH = 1.0;
        const SPLASH_COOLDOWN = 1.0;
        const STUN_DURATION = 1.5;
        const FLUID_FORCE_FACTOR = 0.1;
        const DAMPING_FACTOR = 0.80;
        const SPLASH_RADIUS_RATE = 60;
        const SPLASH_OPACITY_RATE = 1.2;
        const MAX_OBSTACLES = 20;
        const OBSTACLE_SPAWN_RATE = 500;
        const OBSTACLE_FLUID_FORCE_FACTOR = DT;
        const MAX_LEVEL = 3;
        const RIVERBANK_MARGIN = 0.05 * SIM_HEIGHT; // 5% of sim height for each bank

        // --- Types (Enums) ---
        const GameState = { StartScreen: 0, Playing: 1, GameOver: 2, LevelComplete: 3 };
        const PlayerType = { Human: 0, Bot: 1 };
        const ObstacleType = { Log: 0, Garbage: 1 };

        // --- Fluid Simulator Class ---
        const U_FIELD = 0;
        const V_FIELD = 0.5;
        const S_FIELD = 1.0;
        class FluidSimulator {
            constructor(density, numX, numY, h) {
                this.density = density;
                this.h = h;
                this.numX = numX + 2;
                this.numY = numY + 2;
                const createGrid = (fill = 0.0) => Array(this.numX).fill(0).map(() => Array(this.numY).fill(fill));
                this.u = createGrid();
                this.v = createGrid();
                this.p = createGrid();
                this.s = createGrid();
                this.m = createGrid(1.0);
                const pipeH = 0.8 * this.numY;
                this.inletMinJ = Math.floor(0.5 * this.numY - 0.5 * pipeH);
                this.inletMaxJ = Math.floor(0.5 * this.numY + 0.5 * pipeH);
                for (let i = 0; i < this.numX; i++) {
                    for (let j = 0; j < this.numY; j++) {
                        this.s[i][j] = (i === 0 || j === 0 || j === this.numY - 1) ? 0.0 : 1.0;
                    }
                }
            }
            integrate(dt, gravity) {
                for (let i = 1; i < this.numX; i++) {
                    for (let j = 1; j < this.numY - 1; j++) {
                        if (this.s[i][j] !== 0.0 && this.s[i][j - 1] !== 0.0) {
                            this.v[i][j] += gravity * dt;
                        }
                    }
                }
            }
            solveIncompressibility(numIters, dt, overRelaxation) {
                const cp = this.density * this.h / dt;
                for (let iter = 0; iter < numIters; iter++) {
                    for (let i = 1; i < this.numX - 1; i++) {
                        for (let j = 1; j < this.numY - 1; j++) {
                            if (this.s[i][j] === 0.0) continue;
                            const s_sum = this.s[i - 1][j] + this.s[i + 1][j] + this.s[i][j - 1] + this.s[i][j + 1];
                            if (s_sum === 0.0) continue;
                            const div = this.u[i + 1][j] - this.u[i][j] + this.v[i][j + 1] - this.v[i][j];
                            const pressureChange = -div / s_sum * overRelaxation;
                            this.p[i][j] += cp * pressureChange;
                            this.u[i][j] -= this.s[i - 1][j] * pressureChange;
                            this.u[i + 1][j] += this.s[i + 1][j] * pressureChange;
                            this.v[i][j] -= this.s[i][j - 1] * pressureChange;
                            this.v[i][j + 1] += this.s[i][j + 1] * pressureChange;
                        }
                    }
                }
            }
            extrapolate() {
                for (let i = 0; i < this.numX; i++) {
                    this.u[i][0] = this.u[i][1];
                    this.u[i][this.numY - 1] = this.u[i][this.numY - 2];
                }
                for (let j = 0; j < this.numY; j++) {
                    this.v[0][j] = this.v[1][j];
                    this.v[this.numX - 1][j] = this.v[this.numX - 2][j];
                }
            }
            sampleField(x, y, fieldType, fieldData) {
                const h1 = 1.0 / this.h, h2 = 0.5 * this.h;
                x = Math.max(Math.min(x, this.numX * this.h), this.h);
                y = Math.max(Math.min(y, this.numY * this.h), this.h);
                let dx = 0.0, dy = 0.0;
                if (fieldType === U_FIELD) dy = h2;
                else if (fieldType === V_FIELD) dx = h2;
                else if (fieldType === S_FIELD) { dx = h2; dy = h2; }
                const x0 = Math.min(Math.floor((x - dx) * h1), this.numX - 2);
                const tx = ((x - dx) - x0 * this.h) * h1;
                const x1 = Math.min(x0 + 1, this.numX - 2);
                const y0 = Math.min(Math.floor((y - dy) * h1), this.numY - 2);
                const ty = ((y - dy) - y0 * this.h) * h1;
                const y1 = Math.min(y0 + 1, this.numY - 2);
                const sx = 1.0 - tx, sy = 1.0 - ty;
                return (sx * sy * fieldData[x0][y0] + tx * sy * fieldData[x1][y0] + tx * ty * fieldData[x1][y1] + sx * ty * fieldData[x0][y1]);
            }
            advectVel(dt) {
                const newU = this.u.map(row => [...row]);
                const newV = this.v.map(row => [...row]);
                const h2 = 0.5 * this.h;
                for (let i = 1; i < this.numX - 1; i++) {
                    for (let j = 1; j < this.numY - 1; j++) {
                        if (this.s[i][j] !== 0.0 && this.s[i - 1][j] !== 0.0) {
                            const avgV = (this.v[i - 1][j] + this.v[i][j] + this.v[i - 1][j + 1] + this.v[i][j + 1]) * 0.25;
                            let posX = i * this.h, posY = j * this.h + h2;
                            posX -= dt * this.u[i][j];
                            posY -= dt * avgV;
                            newU[i][j] = this.sampleField(posX, posY, U_FIELD, this.u);
                        }
                        if (this.s[i][j] !== 0.0 && this.s[i][j - 1] !== 0.0) {
                            const avgU = (this.u[i][j - 1] + this.u[i][j] + this.u[i + 1][j - 1] + this.u[i + 1][j]) * 0.25;
                            let posX = i * this.h + h2, posY = j * this.h;
                            posX -= dt * avgU;
                            posY -= dt * this.v[i][j];
                            newV[i][j] = this.sampleField(posX, posY, V_FIELD, this.v);
                        }
                    }
                }
                this.u = newU;
                this.v = newV;
            }
            advectSmoke(dt) {
                const newM = this.m.map(row => [...row]);
                const h2 = 0.5 * this.h;
                for (let i = 1; i < this.numX - 1; i++) {
                    for (let j = 1; j < this.numY - 1; j++) {
                        if (this.s[i][j] !== 0.0) {
                            const avgU = (this.u[i][j] + this.u[i + 1][j]) * 0.5;
                            const avgV = (this.v[i][j] + this.v[i][j + 1]) * 0.5;
                            const x = i * this.h + h2 - dt * avgU;
                            const y = j * this.h + h2 - dt * avgV;
                            newM[i][j] = this.sampleField(x, y, S_FIELD, this.m);
                        }
                    }
                }
                this.m = newM;
            }
            simulate(dt, gravity, numIters, overRelaxation, flowVelocity, currentTime) {
                for (let j = 1; j < this.numY - 1; j++) this.u[1][j] = 0.0;
                const inletCenterJ = (this.inletMinJ + this.inletMaxJ) / 2.0;
                const inletHalfWidth = (this.inletMaxJ - this.inletMinJ) / 2.0;
                const waveFrequency = 2.0, waveAmplitude = 0.4;
                const timeBasedVelocity = flowVelocity * (1.0 + waveAmplitude * Math.cos(currentTime * waveFrequency));
                if (inletHalfWidth > 0) {
                    for (let j = this.inletMinJ; j < this.inletMaxJ; j++) {
                        const relativePos = (j - inletCenterJ) / inletHalfWidth;
                        const speed = timeBasedVelocity * (1 - relativePos * relativePos);
                        this.u[1][j] = Math.max(0.0, speed);
                    }
                }
                for (let j = this.inletMinJ; j < this.inletMaxJ; j++) this.m[1][j] = 0.0;
                this.integrate(dt, gravity);
                for (let i = 0; i < this.numX; i++) for (let j = 0; j < this.numY; j++) this.p[i][j] = 0.0;
                this.solveIncompressibility(numIters, dt, overRelaxation);
                this.extrapolate();
                this.advectVel(dt);
                this.advectSmoke(dt);
            }
        }

        // --- Main App ---
        document.addEventListener('DOMContentLoaded', () => {
            // State
            let currentGameState = GameState.StartScreen;
            let winner = null;
            let level = 1;
            let animationFrameId = 0;
            let isGameOver = false;
            let splashStrength = 1.0;

            // Game Objects
            let fluid = null;
            let ducks = [];
            let obstacles = [];
            let splashes = [];
            
            // Timers
            let lastObstacleSpawnTime = 0;
            let lastFrameTime = performance.now();

            // DOM Elements
            const screens = {
                start: document.getElementById('start-screen'),
                levelComplete: document.getElementById('level-complete-screen'),
                gameOver: document.getElementById('game-over-screen'),
                canvasContainer: document.getElementById('game-canvas-container'),
            };
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const gameUi = document.getElementById('game-ui');
            
            // UI Elements
            const startButton = document.getElementById('start-button');
            const nextLevelButton = document.getElementById('next-level-button');
            const restartButton = document.getElementById('restart-button');
            const levelDisplay = document.getElementById('level-display');
            const splashStrengthSlider = document.getElementById('splashStrength');
            const splashStrengthValue = document.getElementById('splash-strength-value');
            const levelCompleteTitle = document.getElementById('level-complete-title');
            const levelCompleteDesc = document.getElementById('level-complete-desc');
            const gameOverText = document.getElementById('game-over-text');
            
            // Setup
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            gameUi.style.width = `${CANVAS_WIDTH}px`;

            // --- Game Logic Functions ---
            
            function createSplash(simX, simY, strength) {
                splashes.push({ x: simX, y: simY, radius: 10, opacity: 1 });
                ducks.forEach(duck => {
                    if (duck.stunned > 0) return;
                    const dx = duck.x - simX;
                    const dy = duck.y - simY;
                    const dist = Math.hypot(dx, dy);
                    if (dist > 0.01 && dist < SPLASH_EFFECT_RADIUS) {
                        const falloff = 1 - (dist / SPLASH_EFFECT_RADIUS);
                        duck.vx += (dx / dist) * strength * falloff;
                        duck.vy += (dy / dist) * strength * falloff;
                    }
                });
            }
            
            function spawnObstacle() {
                let obstacleType;
                if (level === 1) obstacleType = ObstacleType.Log;
                else if (level === 2) obstacleType = ObstacleType.Garbage;
                else obstacleType = Math.random() < 0.5 ? ObstacleType.Log : ObstacleType.Garbage;
                obstacles.push({
                    id: Date.now() + Math.random(),
                    x: -0.1 * SIM_WIDTH,
                    y: RIVERBANK_MARGIN + (SIM_HEIGHT - 2 * RIVERBANK_MARGIN) * Math.random(),
                    vx: 0, vy: 0,
                    width: 0.08 + Math.random() * 0.07,
                    height: 0.03 + Math.random() * 0.02,
                    angle: Math.random() * Math.PI * 2,
                    type: obstacleType,
                });
            }

            function initializeGame() {
                isGameOver = false;
                splashes = [];
                const simWidth = CANVAS_WIDTH / C_SCALE;
                const domainHeight = SIM_HEIGHT;
                const h = domainHeight / RESOLUTION;
                const numY = RESOLUTION;
                const numX = Math.floor(simWidth / h);
                fluid = new FluidSimulator(1000.0, numX, numY, h);

                ducks = [];
                const playerColors = ['#FFD700', '#FF69B4', '#00BFFF', '#32CD32'];
                const playerNames = ['You', 'Bot Alice', 'Bot Bob'];
                const takenPositions = new Set();
                for (let i = 0; i < NUM_PLAYERS; i++) {
                    const startX = 0.1 * SIM_WIDTH;
                    let startY;
                    do { 
                        startY = RIVERBANK_MARGIN + (SIM_HEIGHT - 2 * RIVERBANK_MARGIN) * (0.1 + Math.random() * 0.8);
                    } while (takenPositions.has(Math.floor(startY * 10)));
                    takenPositions.add(Math.floor(startY * 10));
                    ducks.push({
                        id: i, name: playerNames[i],
                        x: startX, y: startY, startX: startX, startY: startY,
                        vx: 0, vy: 0, color: playerColors[i],
                        type: i === 0 ? PlayerType.Human : PlayerType.Bot,
                        splashCooldown: 0, stunned: 0,
                    });
                }
                obstacles = [];
                lastObstacleSpawnTime = performance.now();
            }

            function draw() {
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // --- Draw Riverbanks ---
                const bankTopY = RIVERBANK_MARGIN * C_SCALE;
                const bankBottomY = CANVAS_HEIGHT - RIVERBANK_MARGIN * C_SCALE;
                const waveAmplitude = 8;
                const waveLength = 100;

                ctx.fillStyle = '#228B22'; // Forest Green

                // Top bank
                ctx.beginPath();
                ctx.moveTo(0, 0);
                for (let x = 0; x <= CANVAS_WIDTH; x += 10) {
                    const y = bankTopY + Math.sin(x / waveLength) * waveAmplitude;
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(CANVAS_WIDTH, 0);
                ctx.closePath();
                ctx.fill();

                // Bottom bank
                ctx.beginPath();
                ctx.moveTo(0, CANVAS_HEIGHT);
                for (let x = 0; x <= CANVAS_WIDTH; x += 10) {
                    const y = bankBottomY + Math.sin(x / waveLength + Math.PI) * waveAmplitude;
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.closePath();
                ctx.fill();


                if (fluid) {
                    const h = fluid.h;
                    for (let i = 0; i < fluid.numX; i++) {
                        for (let j = 0; j < fluid.numY; j++) {
                            const alpha = (1 - fluid.m[i][j]) * 0.15;
                            if (alpha > 0.01) {
                                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                                ctx.fillRect(i * h * C_SCALE, j * h * C_SCALE, h * C_SCALE, h * C_SCALE);
                            }
                        }
                    }
                }
                
                ctx.strokeStyle = 'red'; ctx.lineWidth = 3; ctx.setLineDash([10, 10]);
                ctx.beginPath();
                const finishLineCanvasX = FINISH_LINE_X * CANVAS_WIDTH;
                ctx.moveTo(finishLineCanvasX, 0);
                ctx.lineTo(finishLineCanvasX, CANVAS_HEIGHT);
                ctx.stroke();
                ctx.setLineDash([]);

                obstacles.forEach(obs => {
                    ctx.save();
                    ctx.translate(obs.x * C_SCALE, obs.y * C_SCALE);
                    ctx.rotate(obs.angle);
                    if (obs.type === ObstacleType.Log) {
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(-obs.width / 2 * C_SCALE, -obs.height / 2 * C_SCALE, obs.width * C_SCALE, obs.height * C_SCALE);
                    } else {
                        ctx.fillStyle = '#556B2F';
                        ctx.beginPath(); ctx.arc(0, 0, obs.width/2 * C_SCALE, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = 'rgba(128, 128, 128, 0.7)';
                        ctx.beginPath(); ctx.arc(obs.width/4 * C_SCALE, -obs.width/5 * C_SCALE, obs.width/6 * C_SCALE, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.restore();
                });

                splashes.forEach(splash => {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${splash.opacity})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(splash.x * C_SCALE, splash.y * C_SCALE, splash.radius, 0, 2 * Math.PI);
                    ctx.stroke();
                });

                ducks.forEach(duck => {
                    ctx.save();
                    ctx.translate(duck.x * C_SCALE, duck.y * C_SCALE);
                    ctx.rotate(Math.atan2(duck.vy, duck.vx));
                    ctx.fillStyle = duck.color;
                    ctx.beginPath(); ctx.arc(0, 0, DUCK_SIZE, 0, 2 * Math.PI); ctx.fill();
                    ctx.fillStyle = '#FFA500';
                    ctx.beginPath(); ctx.moveTo(DUCK_SIZE - 2, 0); ctx.lineTo(DUCK_SIZE + 10, -4); ctx.lineTo(DUCK_SIZE + 10, 4); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = '#000000';
                    ctx.beginPath(); ctx.arc(DUCK_SIZE / 2, -DUCK_SIZE / 3, 2, 0, 2 * Math.PI); ctx.fill();
                    if (duck.stunned > 0) {
                        ctx.strokeStyle = '#333'; ctx.lineWidth = 1.5;
                        ctx.beginPath(); ctx.arc(0, -DUCK_SIZE, DUCK_SIZE * 0.8, Math.PI * 1.5, Math.PI * 1.5 + (Math.PI * 2 * (duck.stunned / STUN_DURATION))); ctx.stroke();
                    }
                    ctx.restore();
                });
            }

            function update(currentTime) {
                const deltaTime = (currentTime - lastFrameTime) / 1000;
                lastFrameTime = currentTime;

                if (!isGameOver) {
                    splashes = splashes.map(s => ({...s, radius: s.radius + SPLASH_RADIUS_RATE * deltaTime, opacity: s.opacity - SPLASH_OPACITY_RATE * deltaTime, })).filter(s => s.opacity > 0);
                    fluid.simulate(DT, 0.0, NUM_ITERS, OVER_RELAXATION, FLOW_VELOCITY, currentTime / 1000.0);
                    if (currentTime - lastObstacleSpawnTime > OBSTACLE_SPAWN_RATE && obstacles.length < MAX_OBSTACLES) {
                        spawnObstacle();
                        lastObstacleSpawnTime = currentTime;
                    }
                    
                    ducks.forEach(duck => {
                        if (duck.stunned > 0) {
                            duck.stunned = Math.max(0, duck.stunned - deltaTime);
                            duck.vx *= 0.95; duck.vy *= 0.95;
                        } else if (duck.type === PlayerType.Bot && duck.splashCooldown <= 0) {
                            const AVOID_DISTANCE = 0.25;
                            const sortedObstacles = obstacles.filter(obs => obs.x > duck.x && (obs.x - duck.x) < AVOID_DISTANCE)
                                .sort((a,b) => Math.hypot(a.x - duck.x, a.y - duck.y) - Math.hypot(b.x - duck.x, b.y - duck.y));
                            const closestObstacle = sortedObstacles.length > 0 ? sortedObstacles[0] : null;
                            let splashReason = 'none', splashX = 0, splashY = 0;
                            if (closestObstacle && Math.hypot(closestObstacle.x - duck.x, closestObstacle.y - duck.y) < AVOID_DISTANCE) {
                                splashReason = 'avoid'; splashX = closestObstacle.x; splashY = closestObstacle.y;
                            } else {
                                const leadingDuckX = Math.max(...ducks.map(d => d.x));
                                if (duck.x < leadingDuckX - 0.02 * SIM_WIDTH) {
                                    splashReason = 'propel'; splashX = duck.x - (0.1 + Math.random() * 0.05);
                                    const steerDirection = Math.sign(SIM_HEIGHT / 2 - duck.y);
                                    splashY = duck.y - steerDirection * (0.05 + Math.random() * 0.1);
                                }
                            }
                            if (splashReason !== 'none') {
                                duck.splashCooldown = SPLASH_COOLDOWN * (1.2 + Math.random());
                                createSplash(splashX, splashY, (splashReason === 'avoid') ? BOT_SPLASH_STRENGTH * 1.2 : BOT_SPLASH_STRENGTH);
                            }
                        }
                        duck.splashCooldown = Math.max(0, duck.splashCooldown - deltaTime);
                        duck.vx += fluid.sampleField(duck.x, duck.y, 0, fluid.u) * FLUID_FORCE_FACTOR;
                        duck.vy += fluid.sampleField(duck.x, duck.y, 1, fluid.v) * FLUID_FORCE_FACTOR;
                        duck.vx *= DAMPING_FACTOR; duck.vy *= DAMPING_FACTOR;
                        duck.x += duck.vx * DT; duck.y += duck.vy * DT;
                        if (duck.y < RIVERBANK_MARGIN) { duck.y = RIVERBANK_MARGIN; duck.vy *= -0.5; }
                        if (duck.y > SIM_HEIGHT - RIVERBANK_MARGIN) { duck.y = SIM_HEIGHT - RIVERBANK_MARGIN; duck.vy *= -0.5; }
                    });

                    obstacles = obstacles.filter(obs => obs.x < SIM_WIDTH * 1.1);
                    obstacles.forEach(obs => {
                        obs.vx += fluid.sampleField(obs.x, obs.y, 0, fluid.u) * OBSTACLE_FLUID_FORCE_FACTOR;
                        obs.vy += fluid.sampleField(obs.x, obs.y, 1, fluid.v) * OBSTACLE_FLUID_FORCE_FACTOR;
                        obs.vx *= 0.99; obs.vy *= 0.99;
                        obs.x += obs.vx * DT; obs.y += obs.vy * DT;
                    });
                    
                    for (const duck of ducks) {
                        for (const obs of obstacles) {
                            if (Math.hypot(duck.x - obs.x, duck.y - obs.y) < (DUCK_SIZE / C_SCALE + obs.width / 2)) {
                                if (obs.type === ObstacleType.Log) {
                                    duck.stunned = STUN_DURATION;
                                    duck.vx *= -0.5;
                                } else if (obs.type === ObstacleType.Garbage) {
                                    duck.x = duck.startX; duck.y = duck.startY;
                                    duck.vx = 0; duck.vy = 0;
                                    duck.stunned = STUN_DURATION;
                                }
                            }
                        }
                    }

                    const winnerDuck = ducks.find(d => d.x / SIM_WIDTH >= FINISH_LINE_X);
                    if (winnerDuck) {
                        handleGameEnd(winnerDuck.name);
                        return; // Stop this update call
                    }
                }
                draw();
                animationFrameId = requestAnimationFrame(update);
            }
            
            // --- UI & State Management ---

            function updateUI() {
                Object.values(screens).forEach(s => s.classList.add('hidden'));
                switch(currentGameState) {
                    case GameState.StartScreen:
                        screens.start.classList.remove('hidden');
                        break;
                    case GameState.LevelComplete:
                        screens.levelComplete.classList.remove('hidden');
                        levelCompleteTitle.textContent = `Level ${level} Complete!`;
                        const nextLevel = level + 1;
                        let desc = "";
                        if (nextLevel === 2) desc = "Great job! Level 2 has garbage, don't touch it!";
                        else if (nextLevel === 3) desc = "Watch out! Level 3 has both logs and garbage!";
                        levelCompleteDesc.textContent = desc;
                        nextLevelButton.textContent = `Start Level ${nextLevel}`;
                        break;
                    case GameState.GameOver:
                        screens.gameOver.classList.remove('hidden');
                        gameOverText.textContent = winner === 'You' && level === MAX_LEVEL
                            ? `🎉 You beat all the levels! You're the champion! 🎉`
                            : winner?.startsWith('Bot') ? `${winner} won!` : `${winner}`;
                        break;
                    case GameState.Playing:
                        screens.canvasContainer.classList.remove('hidden');
                        levelDisplay.textContent = `Level ${level}`;
                        break;
                }
            }
            
            function handleGameEnd(winnerName) {
                cancelAnimationFrame(animationFrameId);
                winner = winnerName;
                if (winnerName === 'You' && level < MAX_LEVEL) {
                    currentGameState = GameState.LevelComplete;
                } else {
                    currentGameState = GameState.GameOver;
                }
                updateUI();
            }

            function startGameFlow() {
                currentGameState = GameState.Playing;
                updateUI();
                initializeGame();
                lastFrameTime = performance.now();
                animationFrameId = requestAnimationFrame(update);
            }
            
            const startGame = () => { level = 1; startGameFlow(); };
            const restartGame = () => { level = 1; startGameFlow(); };
            const startNextLevel = () => { level++; startGameFlow(); };

            // --- Event Listeners ---
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartGame);
            nextLevelButton.addEventListener('click', startNextLevel);
            splashStrengthSlider.addEventListener('input', (e) => {
                splashStrength = parseFloat(e.target.value);
                splashStrengthValue.textContent = splashStrength.toFixed(1);
            });
            canvas.addEventListener('click', (e) => {
                if (currentGameState !== GameState.Playing) return;
                const rect = canvas.getBoundingClientRect();
                const scaleX = CANVAS_WIDTH / rect.width;
                const scaleY = CANVAS_HEIGHT / rect.height;
                const simX = (e.clientX - rect.left) * scaleX / C_SCALE;
                const simY = (e.clientY - rect.top) * scaleY / C_SCALE;
                
                const clickedObstacleIdx = obstacles.findIndex(obs => Math.hypot(simX - obs.x, simY - obs.y) < obs.width / 2);
                if (clickedObstacleIdx !== -1) {
                    obstacles.splice(clickedObstacleIdx, 1);
                    return;
                }

                const playerDuck = ducks.find(d => d.type === PlayerType.Human);
                if (!playerDuck || playerDuck.stunned > 0 || playerDuck.splashCooldown > 0) return;
                playerDuck.splashCooldown = SPLASH_COOLDOWN;
                createSplash(simX, simY, splashStrength);
            });
            
            // Initial Call
            updateUI();
        });
    </script>
</body>
</html>
