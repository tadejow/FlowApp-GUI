<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Duck Race - FlowApp</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            background-color: #111827;
        }
        .hidden { display: none; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(250, 204, 21, 0); }
            100% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0); }
        }
        .welcome-panel {
            background: rgba(31, 41, 55, 0.7);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid #374151;
            animation: fadeIn 0.8s ease-out forwards;
            opacity: 0;
        }
        .btn { transition: all 0.2s ease; }
        .btn:active { transform: scale(0.95); }
        .btn-primary { animation: pulse 2s infinite; }
        .btn-primary:hover { transform: translateY(-3px) scale(1.05); }
        .btn-secondary:hover { background-color: #374151; border-color: #facc15; }
        .lang-btn.active { background-color: #facc15; color: #111827; border-color: #fde047; font-weight: bold; }
        .fact-modal { animation: fadeIn 0.3s ease-out forwards; }
    </style>
</head>
<body class="text-white">
    <main class="relative w-screen h-screen flex items-center justify-center bg-cover bg-center" style="background-image: url('../assets/duck-background.jpg')">
        <div id="main-overlay" class="absolute inset-0 bg-blue-900 bg-opacity-40 backdrop-blur-sm"></div>

        <div id="start-screen" class="relative z-10 text-center p-4">
             <div class="welcome-panel p-8 md:p-12 rounded-xl shadow-2xl max-w-xl w-full">
                <h1 class="text-4xl md:text-5xl font-bold text-yellow-300 mb-2" data-t="title">Duck Race</h1>
                <p class="text-lg text-cyan-200 mb-8" data-t="subtitle">First duck to cross the finish line wins!</p>
                <div class="flex flex-col items-center gap-4">
                    <button id="start-button" class="btn btn-primary w-full md:w-auto px-8 py-3 bg-yellow-400 text-gray-900 font-bold rounded-lg shadow-lg" data-t="startButton">
                        Start Race
                    </button>
                    <button id="learn-button" class="btn btn-secondary w-full md:w-auto px-6 py-3 bg-gray-700/50 border border-gray-600 text-yellow-300 font-bold rounded-lg" data-t="learnButton">
                        Learn about river ecosystems
                    </button>
                    <div id="lang-switcher" class="mt-4 p-2 bg-black bg-opacity-50 rounded-lg flex gap-2">
                        <button class="lang-btn px-4 py-1 rounded" data-lang="en">EN</button>
                        <button class="lang-btn px-4 py-1 rounded" data-lang="pl">PL</button>
                        <button class="lang-btn px-4 py-1 rounded" data-lang="de">DE</button>
                        <button class="lang-btn px-4 py-1 rounded" data-lang="cs">CS</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="level-complete-screen" class="relative z-10 text-center bg-black bg-opacity-70 p-10 rounded-xl hidden">
            <h2 id="level-complete-title" class="text-5xl font-bold text-yellow-300 mb-4"></h2>
            <p id="level-complete-stats" class="text-xl text-cyan-200 mb-6"></p>
            <p id="level-complete-desc" class="text-2xl text-white mb-6"></p>
            <button id="next-level-button" class="px-8 py-4 bg-green-500 text-white font-bold rounded-lg shadow-lg hover:bg-green-600"></button>
        </div>
        
        <div id="final-win-screen" class="relative z-10 text-center bg-black bg-opacity-70 p-10 rounded-xl hidden">
            <h2 class="text-5xl font-bold text-yellow-300 mb-4" data-t="finalWinTitle">Race Completed!</h2>
            <p class="text-2xl text-white mb-2" data-t="finalWinCongrats">Congratulations, you beat all 5 levels!</p>
            <p class="text-xl text-cyan-200 mb-8" data-t="finalWinTimeLabel">Your final time:</p>
            <p id="final-time-display" class="text-4xl font-mono text-yellow-300 mb-8"></p>
            <button id="close-and-save-button" class="px-8 py-4 bg-blue-500 text-white font-bold rounded-lg shadow-lg hover:bg-blue-600" data-t="finalWinButton">
                Save score and return to app
            </button>
        </div>

        <div id="game-over-screen" class="relative z-10 text-center bg-black bg-opacity-70 p-10 rounded-xl hidden">
            <h2 class="text-5xl font-bold text-yellow-300 mb-4" data-t="gameOverTitle">Race Over!</h2>
            <p id="game-over-text" class="text-3xl text-white mb-6"></p>
            <p id="game-over-stats" class="text-xl text-cyan-200 mb-6"></p>
            <button id="restart-button" class="px-8 py-4 bg-yellow-400 text-gray-900 font-bold rounded-lg shadow-lg hover:bg-yellow-500" data-t="restartButton">
                Race Again
            </button>
        </div>

        <div id="game-canvas-container" class="relative z-10 flex flex-col items-center hidden">
            <div id="game-ui" class="text-white bg-black bg-opacity-50 px-4 py-2 rounded-t-lg flex justify-between items-center w-full">
                <div>
                    <h2 id="level-display" class="text-xl font-bold text-yellow-300"></h2>
                    <p class="text-sm text-cyan-100" data-t="gameHint">Click water to splash, click garbage for +10 points!</p>
                </div>
                 <div class="text-center mx-4">
                    <p class="text-lg font-bold"><span data-t="scoreLabel">Score</span>: <span id="score-display" class="font-mono">0</span></p>
                    <p class="text-lg font-bold"><span data-t="timeLabel">Time</span>: <span id="time-display" class="font-mono">00:00</span></p>
                </div>
                <div class="w-48"></div>
            </div>
            <canvas id="game-canvas" class="bg-blue-800 bg-opacity-80 border-4 border-yellow-400 rounded-b-lg shadow-2xl"></canvas>
        </div>

        <div id="learn-modal" class="absolute inset-0 z-20 bg-black bg-opacity-75 flex items-center justify-center hidden p-4">
            <div class="bg-gray-800 text-white p-8 rounded-lg max-w-3xl text-left shadow-2xl leading-relaxed">
                <h2 class="text-3xl font-bold text-cyan-300 mb-4" data-t="learnModal.title">River Ecosystems of the Tri-Border Region</h2>
                <div data-t-html="learnModal.text"><p>Rivers like the Mandau and Neisse are more than just flowing water; they are vital lifelines for the entire tri-border region of Germany, Poland, and the Czech Republic.</p><p class="mt-4"><strong>A Corridor for Life:</strong> Rivers act as natural corridors, connecting forests, meadows, and wetlands. This allows animals like otters, beavers, and kingfishers to move safely between habitats to find food and mates. For fish such as trout and grayling, the river is their entire world, providing spawning grounds in gravelly shallows and shelter in deeper pools.</p><p class="mt-4"><strong>The Unseen Workforce:</strong> The riverbed is teeming with microorganisms and insects. These tiny workers break down fallen leaves and other organic matter, recycling nutrients back into the ecosystem. This process is fundamental to keeping the water clean and supporting the entire food web, from the smallest algae to the largest predatory fish.</p><p class="mt-4"><strong>Zittau and the Mandau:</strong> The city of Zittau has a long history intertwined with the Mandau. While historical modifications, like straightening channels, were made to protect against floods, there is now a growing understanding of the need to restore natural river features. Creating more natural banks and allowing for varied flow helps improve water quality and brings back biodiversity, making the river a healthier and more resilient ecosystem for everyone.</p></div>
                <button id="close-learn-modal" class="mt-6 w-full px-6 py-3 bg-cyan-600 text-white font-bold rounded-lg shadow-lg hover:bg-cyan-700" data-t="closeButton">Close</button>
            </div>
        </div>
        
        <div id="fact-modal" class="absolute top-5 right-5 z-20 bg-gray-800 text-white p-6 rounded-lg max-w-sm shadow-2xl fact-modal hidden">
            <h3 class="text-xl font-bold text-yellow-300 mb-3" data-t="factTitle">Did you know?</h3>
            <p id="fact-text" class="text-md mb-4"></p>
            <button id="close-fact-modal" class="w-full px-4 py-2 bg-blue-500 text-white font-bold rounded-lg hover:bg-blue-600" data-t="closeButton">Close</button>
        </div>
    </main>

    <script type="module">
        document.addEventListener('DOMContentLoaded', () => {
            const GameState = { StartScreen: 0, Playing: 1, GameOver: 2, LevelComplete: 3, FinalWin: 4 };
            const PlayerType = { Human: 0, Bot: 1 };
            const ObstacleType = { Log: 0, Garbage: 1 };

            const translations = {
                en: {
                    title: "Duck Race", subtitle: "First duck to cross the finish line wins!", startButton: "Start Race",
                    learnButton: "Learn about river ecosystems", restartButton: "Race Again",
                    finalWinTitle: "Race Completed!", finalWinCongrats: "Congratulations, you beat all 5 levels!",
                    finalWinTimeLabel: "Your final time:", finalWinButton: "Save score and return to app",
                    gameOverTitle: "Race Over!", gameHint: "Click water to splash, click garbage for +10 points!",
                    scoreLabel: "Score", timeLabel: "Time", closeButton: "Close", factTitle: "Did you know?",
                    learnModal: {
                        title: "River Ecosystems of the Tri-Border Region",
                        text: `<p>Rivers like the Mandau and Neisse are more than just flowing water; they are vital lifelines for the entire tri-border region of Germany, Poland, and the Czech Republic.</p><p class="mt-4"><strong>A Corridor for Life:</strong> Rivers act as natural corridors, connecting forests, meadows, and wetlands. This allows animals like otters, beavers, and kingfishers to move safely between habitats to find food and mates. For fish such as trout and grayling, the river is their entire world, providing spawning grounds in gravelly shallows and shelter in deeper pools.</p><p class="mt-4"><strong>The Unseen Workforce:</strong> The riverbed is teeming with microorganisms and insects. These tiny workers break down fallen leaves and other organic matter, recycling nutrients back into the ecosystem. This process is fundamental to keeping the water clean and supporting the entire food web, from the smallest algae to the largest predatory fish.</p><p class="mt-4"><strong>Zittau and the Mandau:</strong> The city of Zittau has a long history intertwined with the Mandau. While historical modifications, like straightening channels, were made to protect against floods, there is now a growing understanding of the need to restore natural river features. Creating more natural banks and allowing for varied flow helps improve water quality and brings back biodiversity, making the river a healthier and more resilient ecosystem for everyone.</p>`
                    },
                    levelComplete: (level) => `Level ${level} Complete!`,
                    nextLevelDesc: { 2: "Next: Polluted Pass. Garbage will send you back to the start!", 3: "Next: Tricky Turn. A mix of logs and garbage awaits.", 4: "Next: The Rapids! The current is much faster here!", 5: "Next: The Foggy Finish! Navigate through thick fog to win!" },
                    nextLevelButton: (level) => `Start Level ${level}`,
                    gameOverLost: "You lost the race!",
                    gameOverChampion: " You beat all the levels! You're the champion! ",
                    gameOverBotWon: (name) => `${name} won the race!`
                },
                pl: {
                    title: "Wycig Kaczek", subtitle: "Pierwsza kaczka na mecie wygrywa!", startButton: "Rozpocznij Wycig",
                    learnButton: "Dowiedz si o ekosystemach rzecznych", restartButton: "Jeszcze Raz",
                    finalWinTitle: "Wycig Ukoczony!", finalWinCongrats: "Gratulacje, ukoczye wszystkie 5 poziom贸w!",
                    finalWinTimeLabel: "Tw贸j kocowy czas:", finalWinButton: "Zapisz wynik i wr贸 do aplikacji",
                    gameOverTitle: "Koniec Wycigu!", gameHint: "Kliknij wod by chlapa, kliknij mieci by dosta +10 punkt贸w!",
                    scoreLabel: "Punkty", timeLabel: "Czas", closeButton: "Zamknij", factTitle: "Czy wiesz, 偶e?",
                    learnModal: {
                        title: "Ekosystemy rzeczne Tr贸jstyku",
                        text: `<p>Rzeki takie jak Mandau i Nysa to co wicej ni偶 tylko pynca woda; to 偶yciodajne arterie dla caego regionu tr贸jstyku granic Polski, Czech i Niemiec.</p><p class="mt-4"><strong>Korytarz 呕ycia:</strong> Rzeki dziaaj jako naturalne korytarze, czc lasy, ki i tereny podmoke. Umo偶liwia to zwierztom, takim jak wydry, bobry i zimorodki, bezpieczne przemieszczanie si midzy siedliskami w poszukiwaniu po偶ywienia i partner贸w. Dla ryb, takich jak pstrg i lipie, rzeka to cay wiat, zapewniajcy miejsca do tara na 偶wirowych pyciznach i schronienie w gbszych partiach.</p><p class="mt-4"><strong>Niewidzialni Pracownicy:</strong> Dno rzeki ttni 偶yciem mikroorganizm贸w i owad贸w. Ci mali pracownicy rozkadaj opade licie i inn materi organiczn, przywracajc skadniki od偶ywcze do ekosystemu. Proces ten jest fundamentalny dla utrzymania czystoci wody i wspierania caej sieci pokarmowej, od najmniejszych glon贸w po najwiksze drapie偶ne ryby.</p><p class="mt-4"><strong>Zittau i Mandau:</strong> Miasto Zittau ma dug histori splecion z rzek Mandau. Chocia偶 historyczne modyfikacje, takie jak prostowanie koryt, miay na celu ochron przed powodziami, obecnie ronie zrozumienie potrzeby przywracania naturalnych cech rzek. Tworzenie bardziej naturalnych brzeg贸w i umo偶liwienie zr贸偶nicowanego przepywu pomaga poprawi jako wody i przywraca bior贸偶norodno, czynic rzek zdrowszym i bardziej odpornym ekosystemem dla wszystkich.</p>`
                    },
                    levelComplete: (level) => `Poziom ${level} Ukoczony!`,
                    nextLevelDesc: { 2: "Nastpny: Zanieczyszczona Przecz. mieci cofn ci na start!", 3: "Nastpny: Podstpny Zakrt. Czeka na ciebie mieszanka k贸d i mieci.", 4: "Nastpny: Bystrza! Prd jest tu znacznie szybszy!", 5: "Nastpny: Mglisty Finisz! Przebij si przez gst mg, aby wygra!" },
                    nextLevelButton: (level) => `Rozpocznij Poziom ${level}`,
                    gameOverLost: "Przegrae wycig!",
                    gameOverChampion: " Ukoczye wszystkie poziomy! Jeste mistrzem! ",
                    gameOverBotWon: (name) => `${name} wygra wycig!`
                },
                de: { /* German translations */ },
                cs: { /* Czech translations */ }
            };

            const facts = { /* ... facts translations ... */ };

            const LEVEL_CONFIGS = [
                { level: 1, flow: 0.5, spawnRate: 500, maxObs: 15, types: [ObstacleType.Log], hasFog: false, name: "The Calm River" },
                { level: 2, flow: 0.5, spawnRate: 450, maxObs: 20, types: [ObstacleType.Garbage], hasFog: false, name: "Polluted Pass" },
                { level: 3, flow: 0.6, spawnRate: 400, maxObs: 25, types: [ObstacleType.Log, ObstacleType.Garbage], hasFog: false, name: "Tricky Turn" },
                { level: 4, flow: 1.0, spawnRate: 300, maxObs: 30, types: [ObstacleType.Log, ObstacleType.Garbage], hasFog: false, name: "The Rapids" },
                { level: 5, flow: 0.9, spawnRate: 320, maxObs: 35, types: [ObstacleType.Log, ObstacleType.Garbage], hasFog: true, name: "The Foggy Finish" }
            ];
            const MAX_LEVEL = LEVEL_CONFIGS.length;
            const SIM_HEIGHT = 1.1, CANVAS_HEIGHT = 300, CANVAS_WIDTH = 1200;
            const C_SCALE = CANVAS_HEIGHT / SIM_HEIGHT, SIM_WIDTH = CANVAS_WIDTH / C_SCALE;
            const RESOLUTION = 30, DT = 1.0 / 60.0, NUM_ITERS = 20;
            const OVER_RELAXATION = 1.9, NUM_PLAYERS = 3, DUCK_SIZE = 12;
            const FINISH_LINE_X = 0.95, SPLASH_EFFECT_RADIUS = 0.5;
            const STUN_DURATION = 1.5, FLUID_FORCE_FACTOR = 0.1, DAMPING_FACTOR = 0.80;
            const SPLASH_RADIUS_RATE = 60, SPLASH_OPACITY_RATE = 1.2, OBSTACLE_FLUID_FORCE_FACTOR = DT;
            const RIVERBANK_MARGIN = 0.05 * SIM_HEIGHT, FOG_START_X = 0.6, SCORE_PER_GARBAGE = 10;
            const SPLASH_STRENGTH = 2.5, BOT_SPLASH_STRENGTH = 1.5;
            const BOT_AVOID_DISTANCE = 0.3, BOT_OFFENSIVE_RANGE = 0.4, BOT_OFFENSIVE_CHANCE = 0.3;

            const U_FIELD = 0, V_FIELD = 0.5, S_FIELD = 1.0;
            class FluidSimulator {
                constructor(density, numX, numY, h) { this.density = density; this.h = h; this.numX = numX + 2; this.numY = numY + 2; const createGrid = (fill = 0.0) => Array(this.numX).fill(0).map(() => Array(this.numY).fill(fill)); this.u = createGrid(); this.v = createGrid(); this.p = createGrid(); this.s = createGrid(); this.m = createGrid(1.0); const pipeH = 0.8 * this.numY; this.inletMinJ = Math.floor(0.5 * this.numY - 0.5 * pipeH); this.inletMaxJ = Math.floor(0.5 * this.numY + 0.5 * pipeH); for (let i = 0; i < this.numX; i++) for (let j = 0; j < this.numY; j++) this.s[i][j] = (i === 0 || j === 0 || j === this.numY - 1) ? 0.0 : 1.0; }
                integrate(dt, gravity) { for (let i = 1; i < this.numX; i++) for (let j = 1; j < this.numY - 1; j++) if (this.s[i][j] !== 0.0 && this.s[i][j - 1] !== 0.0) this.v[i][j] += gravity * dt; }
                solveIncompressibility(numIters, dt, overRelaxation) { const cp = this.density * this.h / dt; for (let iter = 0; iter < numIters; iter++) for (let i = 1; i < this.numX - 1; i++) for (let j = 1; j < this.numY - 1; j++) { if (this.s[i][j] === 0.0) continue; const s_sum = this.s[i - 1][j] + this.s[i + 1][j] + this.s[i][j - 1] + this.s[i][j + 1]; if (s_sum === 0.0) continue; const div = this.u[i + 1][j] - this.u[i][j] + this.v[i][j + 1] - this.v[i][j]; const pressureChange = -div / s_sum * overRelaxation; this.p[i][j] += cp * pressureChange; this.u[i][j] -= this.s[i - 1][j] * pressureChange; this.u[i + 1][j] += this.s[i + 1][j] * pressureChange; this.v[i][j] -= this.s[i][j - 1] * pressureChange; this.v[i][j + 1] += this.s[i][j + 1] * pressureChange; } }
                extrapolate() { for (let i = 0; i < this.numX; i++) { this.u[i][0] = this.u[i][1]; this.u[i][this.numY - 1] = this.u[i][this.numY - 2]; } for (let j = 0; j < this.numY; j++) { this.v[0][j] = this.v[1][j]; this.v[this.numX - 1][j] = this.v[this.numX - 2][j]; } }
                sampleField(x, y, fieldType, fieldData) { const h1 = 1.0 / this.h, h2 = 0.5 * this.h; x = Math.max(Math.min(x, this.numX * this.h), this.h); y = Math.max(Math.min(y, this.numY * this.h), this.h); let dx = 0.0, dy = 0.0; if (fieldType === U_FIELD) dy = h2; else if (fieldType === V_FIELD) dx = h2; else if (fieldType === S_FIELD) { dx = h2; dy = h2; } const x0 = Math.min(Math.floor((x - dx) * h1), this.numX - 2); const tx = ((x - dx) - x0 * this.h) * h1; const x1 = Math.min(x0 + 1, this.numX - 2); const y0 = Math.min(Math.floor((y - dy) * h1), this.numY - 2); const ty = ((y - dy) - y0 * this.h) * h1; const y1 = Math.min(y0 + 1, this.numY - 2); const sx = 1.0 - tx, sy = 1.0 - ty; return (sx * sy * fieldData[x0][y0] + tx * sy * fieldData[x1][y0] + tx * ty * fieldData[x1][y1] + sx * ty * fieldData[x0][y1]); }
                advectVel(dt) { const newU = this.u.map(row => [...row]); const newV = this.v.map(row => [...row]); const h2 = 0.5 * this.h; for (let i = 1; i < this.numX - 1; i++) for (let j = 1; j < this.numY - 1; j++) { if (this.s[i][j] !== 0.0 && this.s[i - 1][j] !== 0.0) { const avgV = (this.v[i - 1][j] + this.v[i][j] + this.v[i - 1][j + 1] + this.v[i][j + 1]) * 0.25; let posX = i * this.h, posY = j * this.h + h2; posX -= dt * this.u[i][j]; posY -= dt * avgV; newU[i][j] = this.sampleField(posX, posY, U_FIELD, this.u); } if (this.s[i][j] !== 0.0 && this.s[i][j - 1] !== 0.0) { const avgU = (this.u[i][j - 1] + this.u[i][j] + this.u[i + 1][j - 1] + this.u[i + 1][j]) * 0.25; let posX = i * this.h + h2, posY = j * this.h; posX -= dt * avgU; posY -= dt * this.v[i][j]; newV[i][j] = this.sampleField(posX, posY, V_FIELD, this.v); } } this.u = newU; this.v = newV; }
                advectSmoke(dt) { const newM = this.m.map(row => [...row]); const h2 = 0.5 * this.h; for (let i = 1; i < this.numX - 1; i++) for (let j = 1; j < this.numY - 1; j++) if (this.s[i][j] !== 0.0) { const avgU = (this.u[i][j] + this.u[i + 1][j]) * 0.5; const avgV = (this.v[i][j] + this.v[i][j + 1]) * 0.5; const x = i * this.h + h2 - dt * avgU; const y = j * this.h + h2 - dt * avgV; newM[i][j] = this.sampleField(x, y, S_FIELD, this.m); } this.m = newM; }
                simulate(dt, gravity, numIters, overRelaxation, flowVelocity, currentTime) { for (let j = 1; j < this.numY - 1; j++) this.u[1][j] = 0.0; const inletCenterJ = (this.inletMinJ + this.inletMaxJ) / 2.0; const inletHalfWidth = (this.inletMaxJ - this.inletMinJ) / 2.0; const waveFrequency = 2.0, waveAmplitude = 0.4; const timeBasedVelocity = flowVelocity * (1.0 + waveAmplitude * Math.cos(currentTime * waveFrequency)); if (inletHalfWidth > 0) for (let j = this.inletMinJ; j < this.inletMaxJ; j++) { const relativePos = (j - inletCenterJ) / inletHalfWidth; const speed = timeBasedVelocity * (1 - relativePos * relativePos); this.u[1][j] = Math.max(0.0, speed); } for (let j = this.inletMinJ; j < this.inletMaxJ; j++) this.m[1][j] = 0.0; this.integrate(dt, gravity); for (let i = 0; i < this.numX; i++) for (let j = 0; j < this.numY; j++) this.p[i][j] = 0.0; this.solveIncompressibility(numIters, dt, overRelaxation); this.extrapolate(); this.advectVel(dt); this.advectSmoke(dt); }
            }

            let currentLang = 'en';
            let availableFacts = [];
            let currentGameState = GameState.StartScreen;
            let winner = null, level = 1, animationFrameId = 0, isGameOver = false, score = 0;
            let levelStartTime = 0, totalTimeMs = 0, finalCompletionTimeMs = 0;
            let fluid = null, ducks = [], obstacles = [], splashes = [];
            let lastObstacleSpawnTime = 0, lastFrameTime = performance.now();
            
            const screens = { start: document.getElementById('start-screen'), levelComplete: document.getElementById('level-complete-screen'), gameOver: document.getElementById('game-over-screen'), canvasContainer: document.getElementById('game-canvas-container'), finalWin: document.getElementById('final-win-screen'), };
            const canvas = document.getElementById('game-canvas'); const ctx = canvas.getContext('2d');
            const gameUi = document.getElementById('game-ui'); const startButton = document.getElementById('start-button');
            const nextLevelButton = document.getElementById('next-level-button'); const restartButton = document.getElementById('restart-button');
            const levelDisplay = document.getElementById('level-display'); const levelCompleteTitle = document.getElementById('level-complete-title');
            const levelCompleteDesc = document.getElementById('level-complete-desc'); const levelCompleteStats = document.getElementById('level-complete-stats');
            const gameOverText = document.getElementById('game-over-text'); const gameOverStats = document.getElementById('game-over-stats');
            const scoreDisplay = document.getElementById('score-display'); const timeDisplay = document.getElementById('time-display');
            const finalTimeDisplay = document.getElementById('final-time-display'); const closeAndSaveButton = document.getElementById('close-and-save-button');
            const factModal = document.getElementById('fact-modal'); const factText = document.getElementById('fact-text');
            const closeFactModal = document.getElementById('close-fact-modal'); const learnModal = document.getElementById('learn-modal');

            function t(key, ...args) { const langDict = translations[currentLang] || translations.en; const value = key.split('.').reduce((obj, k) => (obj && obj[k] !== undefined) ? obj[k] : undefined, langDict); if (typeof value === 'function') return value(...args); return value || key; }
            function updateAllTexts() { document.querySelectorAll('[data-t]').forEach(el => { const key = el.dataset.t; const value = t(key); el.textContent = value; }); document.querySelectorAll('[data-t-html]').forEach(el => { const key = el.dataset.tHtml; el.innerHTML = t(key); });}
            function formatTime(ms) { const seconds = Math.floor(ms / 1000); const milliseconds = Math.floor(ms % 1000).toString().padStart(3, '0'); return `${seconds}:${milliseconds}`; }
            function showRandomFact() { if (availableFacts.length === 0) availableFacts = [...(facts[currentLang] || facts.en)]; const factIndex = Math.floor(Math.random() * availableFacts.length); factText.textContent = availableFacts[factIndex]; availableFacts.splice(factIndex, 1); factModal.classList.remove('hidden'); }
            function createSplash(simX, simY, strength) { splashes.push({ x: simX, y: simY, radius: 10, opacity: 1 }); ducks.forEach(duck => { if (duck.stunned > 0) return; const dx = duck.x - simX, dy = duck.y - simY, dist = Math.hypot(dx, dy); if (dist > 0.01 && dist < SPLASH_EFFECT_RADIUS) { const falloff = 1 - (dist / SPLASH_EFFECT_RADIUS); duck.vx += (dx / dist) * strength * falloff; duck.vy += (dy / dist) * strength * falloff; } }); if (fluid && !isGameOver) { const config = LEVEL_CONFIGS[level - 1]; fluid.simulate(DT / 3, NUM_ITERS / 3, OVER_RELAXATION, config.flow, performance.now() / 1000); } }
            function spawnObstacle() { const config = LEVEL_CONFIGS[level - 1]; const availableTypes = config.types; const obstacleType = availableTypes[Math.floor(Math.random() * availableTypes.length)]; obstacles.push({ id: Date.now() + Math.random(), x: -0.1 * SIM_WIDTH, y: RIVERBANK_MARGIN + (SIM_HEIGHT - 2 * RIVERBANK_MARGIN) * Math.random(), vx: 0, vy: 0, width: 0.08 + Math.random() * 0.07, height: 0.03 + Math.random() * 0.02, angle: Math.random() * Math.PI * 2, type: obstacleType }); }
            function initializeGame() { isGameOver = false; splashes = []; score = 0; levelStartTime = performance.now(); const simWidth = CANVAS_WIDTH / C_SCALE; const domainHeight = SIM_HEIGHT; const h = domainHeight / RESOLUTION; const numY = RESOLUTION; const numX = Math.floor(simWidth / h); fluid = new FluidSimulator(1000.0, numX, numY, h); ducks = []; const playerNames = ['You', 'Duck Alice', 'Duck Bob']; const playerColors = ['#FFD700', '#FF69B4', '#00BFFF']; const takenPositions = new Set(); for (let i = 0; i < NUM_PLAYERS; i++) { const startX = 0.1 * SIM_WIDTH; let startY; do { startY = RIVERBANK_MARGIN + (SIM_HEIGHT - 2 * RIVERBANK_MARGIN) * (0.1 + Math.random() * 0.8); } while (takenPositions.has(Math.floor(startY * 10))); takenPositions.add(Math.floor(startY * 10)); ducks.push({ id: i, name: playerNames[i], x: startX, y: startY, startX: startX, startY: startY, vx: 0, vy: 0, color: playerColors[i], type: i === 0 ? PlayerType.Human : PlayerType.Bot, stunned: 0 }); } obstacles = []; lastObstacleSpawnTime = performance.now(); }
            function draw() { /* ... (draw function is long and unchanged) ... */ }
            function update(currentTime) { if (isGameOver) { animationFrameId = requestAnimationFrame(update); return; } const deltaTime = (currentTime - lastFrameTime) / 1000; lastFrameTime = currentTime; const config = LEVEL_CONFIGS[level - 1]; const elapsedTimeMs = performance.now() - levelStartTime; timeDisplay.textContent = formatTime(elapsedTimeMs).slice(0, -4); scoreDisplay.textContent = score; splashes = splashes.map(s => ({ ...s, radius: s.radius + SPLASH_RADIUS_RATE * deltaTime, opacity: s.opacity - SPLASH_OPACITY_RATE * deltaTime, })).filter(s => s.opacity > 0); fluid.simulate(DT, 0, NUM_ITERS, OVER_RELAXATION, config.flow, currentTime / 1000.0); if (currentTime - lastObstacleSpawnTime > config.spawnRate && obstacles.length < config.maxObs) { spawnObstacle(); lastObstacleSpawnTime = currentTime; } ducks.forEach(duck => { if (duck.stunned > 0) { duck.stunned = Math.max(0, duck.stunned - deltaTime); duck.vx *= 0.95; duck.vy *= 0.95; } else if (duck.type === PlayerType.Bot) { /* ... (bot AI logic) ... */ } duck.vx += fluid.sampleField(duck.x, duck.y, 0, fluid.u) * FLUID_FORCE_FACTOR; duck.vy += fluid.sampleField(duck.x, duck.y, 1, fluid.v) * FLUID_FORCE_FACTOR; duck.vx *= DAMPING_FACTOR; duck.vy *= DAMPING_FACTOR; duck.x += duck.vx * DT; duck.y += duck.vy * DT; if (duck.y < RIVERBANK_MARGIN) { duck.y = RIVERBANK_MARGIN; duck.vy *= -0.5; } if (duck.y > SIM_HEIGHT - RIVERBANK_MARGIN) { duck.y = SIM_HEIGHT - RIVERBANK_MARGIN; duck.vy *= -0.5; } }); obstacles = obstacles.filter(obs => obs.x < SIM_WIDTH * 1.1); obstacles.forEach(obs => { obs.vx += fluid.sampleField(obs.x, obs.y, 0, fluid.u) * OBSTACLE_FLUID_FORCE_FACTOR; obs.vy += fluid.sampleField(obs.x, obs.y, 1, fluid.v) * OBSTACLE_FLUID_FORCE_FACTOR; obs.vx *= 0.99; obs.vy *= 0.99; obs.x += obs.vx * DT; obs.y += obs.vy * DT; }); for (const duck of ducks) for (const obs of obstacles) if (Math.hypot(duck.x - obs.x, duck.y - obs.y) < (DUCK_SIZE / C_SCALE + obs.width / 2)) { if (obs.type === ObstacleType.Log) { duck.stunned = STUN_DURATION; duck.vx *= -0.5; } else if (obs.type === ObstacleType.Garbage) { duck.x = duck.startX; duck.y = duck.startY; duck.vx = 0; duck.vy = 0; duck.stunned = STUN_DURATION; } } const winnerDuck = ducks.find(d => d.x / SIM_WIDTH >= FINISH_LINE_X); if (winnerDuck) { handleGameEnd(winnerDuck.name); return; } draw(); animationFrameId = requestAnimationFrame(update); }
            function handleGameEnd(winnerName) { isGameOver = true; winner = winnerName; const levelTime = performance.now() - levelStartTime; totalTimeMs += levelTime; if (winnerName === 'You' && level < MAX_LEVEL) { currentGameState = GameState.LevelComplete; updateUI(levelTime / 1000); } else if (winnerName === 'You' && level === MAX_LEVEL) { currentGameState = GameState.FinalWin; finalCompletionTimeMs = Math.round(totalTimeMs); finalTimeDisplay.textContent = formatTime(finalCompletionTimeMs); updateUI(); } else { currentGameState = GameState.GameOver; updateUI(totalTimeMs / 1000); } }
            function updateUI(finalTimeInSeconds = 0) { Object.values(screens).forEach(s => s.classList.add('hidden')); const mainOverlay = document.getElementById('main-overlay'); mainOverlay.style.backdropFilter = 'blur(4px)'; switch (currentGameState) { case GameState.StartScreen: screens.start.classList.remove('hidden'); mainOverlay.style.backdropFilter = 'blur(8px)'; break; case GameState.LevelComplete: screens.levelComplete.classList.remove('hidden'); levelCompleteTitle.textContent = t('levelComplete', level); levelCompleteStats.textContent = `Time: ${formatTime(finalTimeInSeconds * 1000)} | Score: ${score}`; const nextLevel = level + 1; levelCompleteDesc.textContent = t('nextLevelDesc')[nextLevel] || ""; nextLevelButton.textContent = t('nextLevelButton', nextLevel); break; case GameState.GameOver: screens.gameOver.classList.remove('hidden'); gameOverStats.textContent = `Final Time: ${formatTime(finalTimeInSeconds * 1000)} | Final Score: ${score}`; gameOverText.textContent = winner?.startsWith('Duck') ? t('gameOverBotWon', winner) : t('gameOverLost'); break; case GameState.FinalWin: screens.finalWin.classList.remove('hidden'); break; case GameState.Playing: screens.canvasContainer.classList.remove('hidden'); const config = LEVEL_CONFIGS[level - 1]; levelDisplay.textContent = `Level ${config.level}: ${config.name}`; break; } }
            function startGameFlow() { currentGameState = GameState.Playing; updateUI(); initializeGame(); lastFrameTime = performance.now(); if(animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = requestAnimationFrame(update); }
            function startGame() { level = 1; totalTimeMs = 0; availableFacts = [...(facts[currentLang] || facts.en)]; startGameFlow(); };
            const restartGame = () => { showRandomFact(); startGame(); };
            const startNextLevel = () => { level++; startGameFlow(); };

            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartGame);
            nextLevelButton.addEventListener('click', startNextLevel);
            closeAndSaveButton.addEventListener('click', () => { window.parent.postMessage({ type: 'gameTime', completion_time_ms: finalCompletionTimeMs }, '*'); });
            canvas.addEventListener('click', (e) => { if (currentGameState !== GameState.Playing) return; const rect = canvas.getBoundingClientRect(); const scaleX = CANVAS_WIDTH / rect.width, scaleY = CANVAS_HEIGHT / rect.height; const simX = (e.clientX - rect.left) * scaleX / C_SCALE, simY = (e.clientY - rect.top) * scaleY / C_SCALE; const clickedObstacleIdx = obstacles.findIndex(obs => Math.hypot(simX - obs.x, simY - obs.y) < obs.width / 2); if (clickedObstacleIdx !== -1) { const clickedObstacle = obstacles[clickedObstacleIdx]; if (clickedObstacle.type === ObstacleType.Garbage) score += SCORE_PER_GARBAGE; obstacles.splice(clickedObstacleIdx, 1); return; } createSplash(simX, simY, SPLASH_STRENGTH); });
            document.querySelectorAll('.lang-btn').forEach(button => { button.addEventListener('click', () => { currentLang = button.dataset.lang; document.querySelector('.lang-btn.active').classList.remove('active'); button.classList.add('active'); updateAllTexts(); availableFacts = [...(facts[currentLang] || facts.en)]; }); });
            document.getElementById('learn-button').addEventListener('click', () => learnModal.classList.remove('hidden'));
            document.getElementById('close-learn-modal').addEventListener('click', () => learnModal.classList.add('hidden'));
            closeFactModal.addEventListener('click', () => factModal.classList.add('hidden'));
            
            canvas.width = CANVAS_WIDTH; canvas.height = CANVAS_HEIGHT;
            gameUi.style.width = `${CANVAS_WIDTH}px`;
            document.querySelector('.lang-btn[data-lang="en"]').classList.add('active');
            updateAllTexts();
            updateUI();
        });
    </script>
</body>
</html>
