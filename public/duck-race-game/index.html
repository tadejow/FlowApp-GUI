<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Duck Race - FlowApp</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; overflow: hidden; background-color: #111827; }
        .hidden { display: none; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(250, 204, 21, 0); } 100% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0); } }
        .panel { background: rgba(31, 41, 55, 0.7); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border: 1px solid #374151; animation: fadeIn 0.8s ease-out forwards; opacity: 0; }
        .btn { transition: all 0.2s ease; }
        .btn:active { transform: scale(0.95); }
        .btn-primary { animation: pulse 2s infinite; }
        .btn-primary:hover { transform: translateY(-3px) scale(1.05); }
        .btn-secondary:hover { background-color: #374151; border-color: #facc15; }
        .lang-btn.active { background-color: #facc15; color: #111827; border-color: #fde047; font-weight: bold; }
        #game-canvas-container { width: 100%; max-width: 1200px; aspect-ratio: 4 / 1; }
        #game-canvas { width: 100%; height: 100%; }
    </style>
</head>
<body class="text-white">
    <main class="relative w-screen h-screen flex items-center justify-center bg-cover bg-center" style="background-image: url('../assets/duck-background.jpg')">
        <div id="main-overlay" class="absolute inset-0 bg-blue-900 bg-opacity-40 backdrop-blur-sm"></div>
        <div id="start-screen" class="relative z-10 text-center p-4">
             <div class="panel p-8 md:p-12 rounded-xl shadow-2xl max-w-xl w-full">
                <h1 class="text-4xl md:text-5xl font-bold text-yellow-300 mb-2" data-t="title"></h1>
                <p class="text-lg text-cyan-200 mb-8" data-t="subtitle"></p>
                <div class="flex flex-col items-center gap-4">
                    <button id="start-button" class="btn btn-primary w-full md:w-auto px-8 py-3 bg-yellow-400 text-gray-900 font-bold rounded-lg shadow-lg" data-t="startButton"></button>
                    <button id="ranking-button" class="btn btn-secondary w-full md:w-auto px-6 py-3 bg-gray-700/50 border border-gray-600 text-yellow-300 font-bold rounded-lg" data-t="rankingButton"></button>
                    <button id="learn-button" class="btn btn-secondary w-full md:w-auto px-6 py-3 bg-gray-700/50 border border-gray-600 text-yellow-300 font-bold rounded-lg" data-t="learnButton"></button>
                    <div id="lang-switcher" class="mt-4 p-2 bg-black bg-opacity-50 rounded-lg flex gap-2">
                        <button class="lang-btn px-4 py-1 rounded" data-lang="en">EN</button>
                        <button class="lang-btn px-4 py-1 rounded" data-lang="pl">PL</button>
                        <button class="lang-btn px-4 py-1 rounded" data-lang="de">DE</button>
                        <button class="lang-btn px-4 py-1 rounded" data-lang="cs">CS</button>
                    </div>
                </div>
            </div>
        </div>
        <div id="level-complete-screen" class="relative z-10 text-center bg-black bg-opacity-70 p-10 rounded-xl hidden">
            <h2 id="level-complete-title" class="text-5xl font-bold text-yellow-300 mb-4"></h2>
            <p id="level-complete-desc" class="text-2xl text-white mb-6"></p>
            <button id="next-level-button" class="px-8 py-4 bg-green-500 text-white font-bold rounded-lg shadow-lg hover:bg-green-600"></button>
        </div>
        <div id="final-win-screen" class="relative z-10 text-center bg-black bg-opacity-70 p-10 rounded-xl hidden">
            <h2 class="text-5xl font-bold text-yellow-300 mb-4" data-t="finalWinTitle"></h2>
            <p class="text-2xl text-white mb-2" data-t="finalWinCongrats"></p>
            <p class="text-xl text-cyan-200 mb-8" data-t="finalWinTimeLabel"></p>
            <p id="final-time-display" class="text-4xl font-mono text-yellow-300 mb-8"></p>
            <button id="close-and-save-button" class="px-8 py-4 bg-blue-500 text-white font-bold rounded-lg shadow-lg hover:bg-blue-600" data-t="finalWinButton"></button>
        </div>
        <div id="game-over-screen" class="relative z-10 text-center bg-black bg-opacity-70 p-10 rounded-xl hidden">
            <h2 class="text-5xl font-bold text-yellow-300 mb-4" data-t="gameOverTitle"></h2>
            <p id="game-over-text" class="text-3xl text-white mb-6"></p>
            <button id="restart-button" class="px-8 py-4 bg-yellow-400 text-gray-900 font-bold rounded-lg shadow-lg hover:bg-yellow-500" data-t="restartButton"></button>
        </div>
        <div id="game-canvas-container" class="relative z-10 flex flex-col items-center hidden">
            <div id="game-ui" class="text-white bg-black bg-opacity-50 px-4 py-2 rounded-t-lg flex justify-between items-center w-full">
                <div>
                    <h2 id="level-display" class="text-xl font-bold text-yellow-300"></h2>
                    <p class="text-sm text-cyan-100" data-t="gameHint"></p>
                </div>
                <div class="text-center mx-4">
                    <p class="text-lg font-bold"><span data-t="timeLabel"></span>: <span id="time-display" class="font-mono">00:000</span></p>
                </div>
                <div class="w-48"></div>
            </div>
            <canvas id="game-canvas" class="bg-blue-800 bg-opacity-80 border-4 border-yellow-400 rounded-b-lg shadow-2xl"></canvas>
        </div>
        <div id="learn-modal" class="absolute inset-0 z-20 bg-black bg-opacity-75 flex items-center justify-center hidden p-4">
            <div class="panel p-8 rounded-lg max-w-3xl text-left shadow-2xl leading-relaxed">
                <h2 class="text-3xl font-bold text-cyan-300 mb-4" data-t="learnModal.title"></h2>
                <div data-t-html="learnModal.text"></div>
                <button id="close-learn-modal" class="btn mt-6 w-full px-6 py-3 bg-cyan-600 text-white font-bold rounded-lg shadow-lg hover:bg-cyan-700" data-t="closeButton"></button>
            </div>
        </div>
        <div id="fact-modal" class="absolute top-5 right-5 z-20 panel p-6 rounded-lg max-w-sm shadow-2xl hidden">
            <h3 class="text-xl font-bold text-yellow-300 mb-3" data-t="factTitle"></h3>
            <p id="fact-text" class="text-md mb-4"></p>
            <button id="close-fact-modal" class="w-full btn px-4 py-2 bg-blue-500 text-white font-bold rounded-lg hover:bg-blue-600" data-t="closeButton"></button>
        </div>
        <div id="leaderboard-modal" class="absolute inset-0 z-20 bg-black bg-opacity-75 flex items-center justify-center hidden p-4">
            <div class="panel p-8 rounded-lg max-w-lg w-full text-left shadow-2xl">
                <h2 class="text-3xl font-bold text-yellow-300 mb-6 text-center" data-t="leaderboard.title"></h2>
                <div id="leaderboard-content" class="max-h-[60vh] overflow-y-auto"></div>
                <button id="close-leaderboard-modal" class="btn mt-6 w-full px-6 py-3 bg-cyan-600 text-white font-bold rounded-lg shadow-lg hover:bg-cyan-700" data-t="closeButton"></button>
            </div>
        </div>
    </main>
    <script type="module">
        document.addEventListener('DOMContentLoaded', () => {
            const GameState = { StartScreen: 0, Playing: 1, GameOver: 2, LevelComplete: 3, FinalWin: 4 };
            const PlayerType = { Human: 0, Bot: 1 };
            const ObstacleType = { Log: 0, Garbage: 1 };

            const translations = {
                en: { title: "Duck Race", subtitle: "First duck to cross the finish line wins!", startButton: "Start Race", learnButton: "Learn about river ecosystems", rankingButton: "Ranking", restartButton: "Race Again", finalWinTitle: "Race Completed!", finalWinCongrats: "Congratulations, you beat all 5 levels!", finalWinTimeLabel: "Your final time:", finalWinButton: "Save score and return to app", gameOverTitle: "Race Over!", gameHint: "Click water to splash, click garbage for +10 points!", timeLabel: "Time", closeButton: "Close", factTitle: "Did you know?", learnModal: { title: "River Ecosystems of the Tri-Border Region", text: `<p>Rivers like the Mandau and Neisse are more than just flowing water; they are vital lifelines for the entire tri-border region of Germany, Poland, and the Czech Republic.</p><p class="mt-4"><strong>A Corridor for Life:</strong> Rivers act as natural corridors, connecting forests, meadows, and wetlands. This allows animals like otters, beavers, and kingfishers to move safely between habitats to find food and mates. For fish such as trout and grayling, the river is their entire world, providing spawning grounds in gravelly shallows and shelter in deeper pools.</p><p class="mt-4"><strong>The Unseen Workforce:</strong> The riverbed is teeming with microorganisms and insects. These tiny workers break down fallen leaves and other organic matter, recycling nutrients back into the ecosystem. This process is fundamental to keeping the water clean and supporting the entire food web, from the smallest algae to the largest predatory fish.</p><p class="mt-4"><strong>Zittau and the Mandau:</strong> The city of Zittau has a long history intertwined with the Mandau. While historical modifications, like straightening channels, were made to protect against floods, there is now a growing understanding of the need to restore natural river features. Creating more natural banks and allowing for varied flow helps improve water quality and brings back biodiversity, making the river a healthier and more resilient ecosystem for everyone.</p>` }, leaderboard: { title: "Leaderboard", loading: "Loading...", error: "Could not load leaderboard.", yourBest: "Your Best Rank:"}, levelComplete: (level) => `Level ${level} Complete!`, nextLevelDesc: (level) => ({ 2: "Next: Polluted Pass. Garbage will send you back to the start!", 3: "Next: Tricky Turn. A mix of logs and garbage awaits.", 4: "Next: The Rapids! The current is much faster here!", 5: "Next: The Foggy Finish! Navigate through thick fog to win!" }[level] || ""), nextLevelButton: (level) => `Start Level ${level}`, gameOverLost: "You lost the race!", gameOverChampion: "üéâ You beat all the levels! You're the champion! üéâ", gameOverBotWon: (name) => `${name} won the race!` },
                pl: { title: "Wy≈õcig Kaczek", subtitle: "Pierwsza kaczka na mecie wygrywa!", startButton: "Rozpocznij Wy≈õcig", learnButton: "Dowiedz siƒô o ekosystemach", rankingButton: "Ranking", restartButton: "Jeszcze Raz", finalWinTitle: "Wy≈õcig Uko≈Ñczony!", finalWinCongrats: "Gratulacje, uko≈Ñczy≈Çe≈õ wszystkie 5 poziom√≥w!", finalWinTimeLabel: "Tw√≥j ko≈Ñcowy czas:", finalWinButton: "Zapisz wynik i wr√≥ƒá", gameOverTitle: "Koniec Wy≈õcigu!", gameHint: "Kliknij wodƒô by chlapaƒá, kliknij ≈õmieci by dostaƒá +10 punkt√≥w!", timeLabel: "Czas", closeButton: "Zamknij", factTitle: "Czy wiesz, ≈ºe?", learnModal: { title: "Ekosystemy rzeczne Tr√≥jstyku", text: `<p>Rzeki takie jak Mandau i Nysa to co≈õ wiƒôcej ni≈º tylko p≈ÇynƒÖca woda; to ≈ºyciodajne arterie dla ca≈Çego regionu tr√≥jstyku granic Polski, Czech i Niemiec.</p><p class="mt-4"><strong>Korytarz ≈ªycia:</strong> Rzeki dzia≈ÇajƒÖ jako naturalne korytarze, ≈ÇƒÖczƒÖc lasy, ≈ÇƒÖki i tereny podmok≈Çe. Umo≈ºliwia to zwierzƒôtom, takim jak wydry, bobry i zimorodki, bezpieczne przemieszczanie siƒô miƒôdzy siedliskami w poszukiwaniu po≈ºywienia i partner√≥w. Dla ryb, takich jak pstrƒÖg i lipie≈Ñ, rzeka to ca≈Çy ≈õwiat, zapewniajƒÖcy miejsca do tar≈Ça na ≈ºwirowych p≈Çyciznach i schronienie w g≈Çƒôbszych partiach.</p><p class="mt-4"><strong>Niewidzialni Pracownicy:</strong> Dno rzeki tƒôtni ≈ºyciem mikroorganizm√≥w i owad√≥w. Ci mali pracownicy rozk≈ÇadajƒÖ opad≈Çe li≈õcie i innƒÖ materiƒô organicznƒÖ, przywracajƒÖc sk≈Çadniki od≈ºywcze do ekosystemu. Proces ten jest fundamentalny dla utrzymania czysto≈õci wody i wspierania ca≈Çej sieci pokarmowej, od najmniejszych glon√≥w po najwiƒôksze drapie≈ºne ryby.</p><p class="mt-4"><strong>Zittau i Mandau:</strong> Miasto Zittau ma d≈ÇugƒÖ historiƒô splecionƒÖ z rzekƒÖ Mandau. Chocia≈º historyczne modyfikacje, takie jak prostowanie koryt, mia≈Çy na celu ochronƒô przed powodziami, obecnie ro≈õnie zrozumienie potrzeby przywracania naturalnych cech rzek. Tworzenie bardziej naturalnych brzeg√≥w i umo≈ºliwienie zr√≥≈ºnicowanego przep≈Çywu pomaga poprawiƒá jako≈õƒá wody i przywraca bior√≥≈ºnorodno≈õƒá, czyniƒÖc rzekƒô zdrowszym i bardziej odpornym ekosystemem dla wszystkich.</p>` }, leaderboard: { title: "Tabela Wynik√≥w", loading: "≈Åadowanie...", error: "Nie uda≈Ço siƒô za≈Çadowaƒá rankingu.", yourBest: "Twoja najlepsza pozycja:"}, levelComplete: (level) => `Poziom ${level} Uko≈Ñczony!`, nextLevelDesc: (level) => ({ 2: "Nastƒôpny: Zanieczyszczona Prze≈Çƒôcz. ≈ömieci cofnƒÖ ciƒô na start!", 3: "Nastƒôpny: Podstƒôpny Zakrƒôt. Czeka na ciebie mieszanka k≈Ç√≥d i ≈õmieci.", 4: "Nastƒôpny: Bystrza! PrƒÖd jest tu znacznie szybszy!", 5: "Nastƒôpny: Mglisty Finisz! Przebij siƒô przez gƒôstƒÖ mg≈Çƒô, aby wygraƒá!" }[level] || ""), nextLevelButton: (level) => `Rozpocznij Poziom ${level}`, gameOverLost: "Przegra≈Çe≈õ wy≈õcig!", gameOverChampion: "üéâ Uko≈Ñczy≈Çe≈õ wszystkie poziomy! Jeste≈õ mistrzem! üéâ", gameOverBotWon: (name) => `${name} wygra≈Ç wy≈õcig!` },
                de: { title: "Entenrennen", subtitle: "Die erste Ente im Ziel gewinnt!", startButton: "Rennen starten", learnButton: "√úber √ñkosysteme lernen", rankingButton: "Rangliste", restartButton: "Nochmal fahren", finalWinTitle: "Rennen beendet!", finalWinCongrats: "Herzlichen Gl√ºckwunsch, du hast alle 5 Level geschafft!", finalWinTimeLabel: "Deine Endzeit:", finalWinButton: "Ergebnis speichern & zur√ºck", gameOverTitle: "Rennen vorbei!", gameHint: "Klicke auf Wasser, um zu spritzen, klicke auf M√ºll f√ºr +10 Punkte!", timeLabel: "Zeit", closeButton: "Schlie√üen", factTitle: "Wusstest du schon?", learnModal: { title: "Fluss√∂kosysteme des Dreil√§nderecks", text: `<p>Fl√ºsse wie die Mandau und die Nei√üe sind mehr als nur flie√üendes Wasser; sie sind lebenswichtige Lebensadern f√ºr das gesamte Dreil√§ndereck Deutschland, Polen und Tschechien.</p><p class="mt-4"><strong>Ein Korridor f√ºr das Leben:</strong> Fl√ºsse fungieren als nat√ºrliche Korridore, die W√§lder, Wiesen und Feuchtgebiete verbinden. Dies erm√∂glicht Tieren wie Ottern, Bibern und Eisv√∂geln, sich sicher zwischen den Lebensr√§umen zu bewegen, um Nahrung und Partner zu finden. F√ºr Fische wie Forellen und √Ñschen ist der Fluss ihre ganze Welt, der ihnen Laichpl√§tze in kiesigen Flachwasserzonen und Schutz in tieferen Gumpen bietet.</p><p class="mt-4"><strong>Die unsichtbaren Arbeiter:</strong> Das Flussbett wimmelt von Mikroorganismen und Insekten. Diese winzigen Arbeiter zersetzen Laub und anderes organisches Material und f√ºhren die N√§hrstoffe wieder dem √ñkosystem zu. Dieser Prozess ist grundlegend, um das Wasser sauber zu halten und das gesamte Nahrungsnetz zu unterst√ºtzen, von der kleinsten Alge bis zum gr√∂√üten Raubfisch.</p><p class="mt-4"><strong>Zittau und die Mandau:</strong> Die Stadt Zittau hat eine lange Geschichte, die eng mit der Mandau verbunden ist. W√§hrend historische Eingriffe wie die Begradigung von Kan√§len dem Hochwasserschutz dienten, w√§chst heute das Verst√§ndnis f√ºr die Notwendigkeit, nat√ºrliche Flussmerkmale wiederherzustellen. Die Schaffung naturnaher Ufer und die Zulassung einer vielf√§ltigen Str√∂mung verbessern die Wasserqualit√§t und f√∂rdern die Artenvielfalt, was den Fluss zu einem ges√ºnderen und widerstandsf√§higeren √ñkosystem f√ºr alle macht.</p>` }, leaderboard: { title: "Bestenliste", loading: "Wird geladen...", error: "Bestenliste konnte nicht geladen werden.", yourBest: "Dein bester Rang:"}, levelComplete: (level) => `Level ${level} abgeschlossen!`, nextLevelDesc: (level) => ({ 2: "N√§chstes: Verschmutzter Pass. M√ºll schickt dich zur√ºck an den Start!", 3: "N√§chstes: Knifflige Kurve. Eine Mischung aus Baumst√§mmen und M√ºll erwartet dich.", 4: "N√§chstes: Die Stromschnellen! Die Str√∂mung ist hier viel schneller!", 5: "N√§chstes: Das neblige Finale! Navigiere durch dichten Nebel, um zu gewinnen!" }[level] || ""), nextLevelButton: (level) => `Level ${level} starten`, gameOverLost: "Du hast das Rennen verloren!", gameOverChampion: "üéâ Du hast alle Level geschafft! Du bist der Champion! üéâ", gameOverBotWon: (name) => `${name} hat das Rennen gewonnen!` },
                cs: { title: "Kachn√≠ Z√°vod", subtitle: "Prvn√≠ kachna v c√≠li vyhr√°v√°!", startButton: "Spustit Z√°vod", learnButton: "O ekosyst√©mech", rankingButton: "≈Ωeb≈ô√≠ƒçek", restartButton: "Znovu z√°vodit", finalWinTitle: "Z√°vod dokonƒçen!", finalWinCongrats: "Gratulujeme, dokonƒçil jsi v≈°ech 5 √∫rovn√≠!", finalWinTimeLabel: "Tv≈Øj koneƒçn√Ω ƒças:", finalWinButton: "Ulo≈æit sk√≥re a vr√°tit se", gameOverTitle: "Konec Z√°vodu!", gameHint: "Klikni na vodu pro ≈°plouchnut√≠, klikni na odpadky pro +10 bod≈Ø!", timeLabel: "ƒåas", closeButton: "Zav≈ô√≠t", factTitle: "Vƒõdƒõl jsi?", learnModal: { title: "≈ò√≠ƒçn√≠ ekosyst√©my Trojmez√≠", text: `<p>≈òeky jako Mandava a Nisa jsou v√≠c ne≈æ jen tekouc√≠ voda; jsou ≈æivotnƒõ d≈Øle≈æit√Ωmi tepnami pro cel√Ω region trojmez√≠ Nƒõmecka, Polska a ƒåesk√© republiky.</p><p class="mt-4"><strong>Koridor pro ≈æivot:</strong> ≈òeky funguj√≠ jako p≈ô√≠rodn√≠ koridory, kter√© spojuj√≠ lesy, louky a mok≈ôady. To umo≈æ≈àuje zv√≠≈ôat≈Øm, jako jsou vydry, bob≈ôi a led≈à√°ƒçci, bezpeƒçnƒõ se pohybovat mezi stanovi≈°ti za potravou a partnery. Pro ryby, jako je pstruh a lipan, je ≈ôeka cel√Ωm jejich svƒõtem, poskytuj√≠c√≠m m√≠sta pro t≈ôen√≠ na ≈°tƒõrkov√Ωch mƒõlƒçin√°ch a √∫kryt v hlub≈°√≠ch t≈Øn√≠ch.</p><p class="mt-4"><strong>Neviditeln√° pracovn√≠ s√≠la:</strong> ≈òeƒçi≈°tƒõ se hem≈æ√≠ mikroorganismy a hmyzem. Tito mal√≠ pracovn√≠ci rozkl√°daj√≠ spadan√© list√≠ a dal≈°√≠ organickou hmotu a recykluj√≠ ≈æiviny zpƒõt do ekosyst√©mu. Tento proces je z√°sadn√≠ pro udr≈æen√≠ ƒçist√© vody a podporu cel√©ho potravn√≠ho ≈ôetƒõzce, od nejmen≈°√≠ch ≈ôas po nejvƒõt≈°√≠ drav√© ryby.</p><p class="mt-4"><strong>≈Ωitava a Mandava:</strong> Mƒõsto ≈Ωitava m√° dlouhou historii spojenou s ≈ôekou Mandavou. Zat√≠mco historick√© √∫pravy, jako je nap≈ôimov√°n√≠ koryt, byly provedeny za √∫ƒçelem ochrany p≈ôed povodnƒõmi, dnes roste porozumƒõn√≠ pro pot≈ôebu obnovy p≈ôirozen√Ωch ≈ô√≠ƒçn√≠ch prvk≈Ø. Vytv√°≈ôen√≠ p≈ôirozenƒõj≈°√≠ch b≈ôeh≈Ø a umo≈ænƒõn√≠ rozmanit√©ho proudƒõn√≠ pom√°h√° zlep≈°it kvalitu vody a navrac√≠ biodiverzitu, ƒç√≠m≈æ se ≈ôeka st√°v√° zdravƒõj≈°√≠m a odolnƒõj≈°√≠m ekosyst√©mem pro v≈°echny.</p>` }, leaderboard: { title: "≈Ωeb≈ô√≠ƒçek", loading: "Naƒç√≠t√°n√≠...", error: "≈Ωeb≈ô√≠ƒçek se nepoda≈ôilo naƒç√≠st.", yourBest: "Tvoje nejlep≈°√≠ pozice:"}, levelComplete: (level) => `√örove≈à ${level} dokonƒçena!`, nextLevelDesc: (level) => ({ 2: "Dal≈°√≠: Zneƒçi≈°tƒõn√Ω pr≈Øsmyk. Odpadky tƒõ po≈°lou zpƒõt na start!", 3: "Dal≈°√≠: Z√°ludn√° zat√°ƒçka. ƒåek√° na tebe smƒõs kl√°d a odpadk≈Ø.", 4: "Dal≈°√≠: Pe≈ôeje! Proud je zde mnohem rychlej≈°√≠!", 5: "Dal≈°√≠: Mlhav√Ω fini≈°! Projdi hustou mlhou a vyhraj!" }[level] || ""), nextLevelButton: (level) => `Spustit √∫rove≈à ${level}`, gameOverLost: "Prohr√°l jsi z√°vod!", gameOverChampion: "üéâ Dokonƒçil jsi v≈°echny √∫rovnƒõ! Jsi ≈°ampion! üéâ", gameOverBotWon: (name) => `${name} vyhr√°l z√°vod!` }
            };

            const facts = {
                en: [ "The length of the Mandau river is about 41km.", "Mandau flows through the Czech Republic, Germany, and borders Poland. Its water travels through 3 countries!", "Fish help control insect populations and recycle nutrients in rivers.", "Microorganisms break down waste and dead plants, keeping rivers clean.", "Rivers connect habitats, allowing animals like otters and beavers to move and breed.", "There are around 245 fish species present in Germany." ],
                pl: [ "D≈Çugo≈õƒá rzeki Mandau wynosi oko≈Ço 41 km.", "Mandau p≈Çynie przez Czechy, Niemcy i graniczy z PolskƒÖ. Jej woda podr√≥≈ºuje przez 3 kraje!", "Ryby pomagajƒÖ kontrolowaƒá populacje owad√≥w i przetwarzajƒÖ sk≈Çadniki od≈ºywcze w rzekach.", "Mikroorganizmy rozk≈ÇadajƒÖ odpady, utrzymujƒÖc czysto≈õƒá rzek.", "Rzeki ≈ÇƒÖczƒÖ siedliska, umo≈ºliwiajƒÖc zwierzƒôtom, takim jak wydry i bobry, przemieszczanie siƒô.", "W Niemczech wystƒôpuje oko≈Ço 245 gatunk√≥w ryb." ],
                de: [ "Die L√§nge der Mandau betr√§gt etwa 41 km.", "Die Mandau flie√üt durch Tschechien, Deutschland und grenzt an Polen. Ihr Wasser reist durch 3 L√§nder!", "Fische helfen, Insektenpopulationen zu kontrollieren und N√§hrstoffe in Fl√ºssen zu recyceln.", "Mikroorganismen zersetzen Abf√§lle und halten so die Fl√ºsse sauber.", "Fl√ºsse verbinden Lebensr√§ume und erm√∂glichen Tieren wie Ottern und Bibern die Fortbewegung.", "In Deutschland gibt es etwa 245 Fischarten." ],
                cs: [ "D√©lka ≈ôeky Mandavy je p≈ôibli≈ænƒõ 41 km.", "Mandava prot√©k√° ƒåeskou republikou, Nƒõmeckem a hraniƒç√≠ s Polskem. Jej√≠ voda putuje p≈ôes 3 zemƒõ!", "Ryby pom√°haj√≠ regulovat populace hmyzu a recyklovat ≈æiviny v ≈ôek√°ch.", "Mikroorganismy rozkl√°daj√≠ odpad a udr≈æuj√≠ tak ≈ôeky ƒçist√©.", "≈òeky propojuj√≠ stanovi≈°tƒõ a umo≈æ≈àuj√≠ zv√≠≈ôat≈Øm, jako jsou vydry a bob≈ôi, pohyb.", "V Nƒõmecku se vyskytuje p≈ôibli≈ænƒõ 245 druh≈Ø ryb." ]
            };

            const LEVEL_CONFIGS = [ { level: 1, flow: 0.5, spawnRate: 500, maxObs: 15, types: [ObstacleType.Log], hasFog: false, name: "The Calm River" }, { level: 2, flow: 0.5, spawnRate: 450, maxObs: 20, types: [ObstacleType.Garbage], hasFog: false, name: "Polluted Pass" }, { level: 3, flow: 0.6, spawnRate: 400, maxObs: 25, types: [ObstacleType.Log, ObstacleType.Garbage], hasFog: false, name: "Tricky Turn" }, { level: 4, flow: 1.0, spawnRate: 300, maxObs: 30, types: [ObstacleType.Log, ObstacleType.Garbage], hasFog: false, name: "The Rapids" }, { level: 5, flow: 0.9, spawnRate: 320, maxObs: 35, types: [ObstacleType.Log, ObstacleType.Garbage], hasFog: true, name: "The Foggy Finish" } ];
            const MAX_LEVEL = LEVEL_CONFIGS.length;
            const SIM_HEIGHT = 1.1; const DUCK_SIZE = 12; const RESOLUTION = 30;
            const DT = 1.0 / 60.0; const NUM_ITERS = 20; const OVER_RELAXATION = 1.9; const NUM_PLAYERS = 3; 
            const FINISH_LINE_X = 0.95; const SPLASH_EFFECT_RADIUS = 0.5;
            const STUN_DURATION = 1.5; const FLUID_FORCE_FACTOR = 0.1; const DAMPING_FACTOR = 0.80;
            const SPLASH_RADIUS_RATE = 60; const SPLASH_OPACITY_RATE = 1.2; const OBSTACLE_FLUID_FORCE_FACTOR = DT;
            const RIVERBANK_MARGIN = 0.05 * SIM_HEIGHT; const FOG_START_X = 0.6; const SCORE_PER_GARBAGE = 10;
            const SPLASH_STRENGTH = 2.5; const BOT_SPLASH_STRENGTH = 1.5;
            const BOT_AVOID_DISTANCE = 0.3; const BOT_OFFENSIVE_RANGE = 0.4; const BOT_OFFENSIVE_CHANCE = 0.3;

            const U_FIELD = 0; const V_FIELD = 0.5; const S_FIELD = 1.0;
            class FluidSimulator { constructor(density, numX, numY, h) { this.density = density; this.h = h; this.numX = numX + 2; this.numY = numY + 2; const createGrid = (fill = 0.0) => Array(this.numX).fill(0).map(() => Array(this.numY).fill(fill)); this.u = createGrid(); this.v = createGrid(); this.p = createGrid(); this.s = createGrid(); this.m = createGrid(1.0); const pipeH = 0.8 * this.numY; this.inletMinJ = Math.floor(0.5 * this.numY - 0.5 * pipeH); this.inletMaxJ = Math.floor(0.5 * this.numY + 0.5 * pipeH); for (let i = 0; i < this.numX; i++) for (let j = 0; j < this.numY; j++) this.s[i][j] = (i === 0 || j === 0 || j === this.numY - 1) ? 0.0 : 1.0; } integrate(dt, gravity) { for (let i = 1; i < this.numX; i++) for (let j = 1; j < this.numY - 1; j++) if (this.s[i][j] !== 0.0 && this.s[i][j - 1] !== 0.0) this.v[i][j] += gravity * dt; } solveIncompressibility(numIters, dt, overRelaxation) { const cp = this.density * this.h / dt; for (let iter = 0; iter < numIters; iter++) for (let i = 1; i < this.numX - 1; i++) for (let j = 1; j < this.numY - 1; j++) { if (this.s[i][j] === 0.0) continue; const s_sum = this.s[i - 1][j] + this.s[i + 1][j] + this.s[i][j - 1] + this.s[i][j + 1]; if (s_sum === 0.0) continue; const div = this.u[i + 1][j] - this.u[i][j] + this.v[i][j + 1] - this.v[i][j]; const pressureChange = -div / s_sum * overRelaxation; this.p[i][j] += cp * pressureChange; this.u[i][j] -= this.s[i - 1][j] * pressureChange; this.u[i + 1][j] += this.s[i + 1][j] * pressureChange; this.v[i][j] -= this.s[i][j - 1] * pressureChange; this.v[i][j + 1] += this.s[i][j + 1] * pressureChange; } } extrapolate() { for (let i = 0; i < this.numX; i++) { this.u[i][0] = this.u[i][1]; this.u[i][this.numY - 1] = this.u[i][this.numY - 2]; } for (let j = 0; j < this.numY; j++) { this.v[0][j] = this.v[1][j]; this.v[this.numX - 1][j] = this.v[this.numX - 2][j]; } } sampleField(x, y, fieldType, fieldData) { const h1 = 1.0 / this.h, h2 = 0.5 * this.h; x = Math.max(Math.min(x, this.numX * this.h), this.h); y = Math.max(Math.min(y, this.numY * this.h), this.h); let dx = 0.0, dy = 0.0; if (fieldType === U_FIELD) dy = h2; else if (fieldType === V_FIELD) dx = h2; else if (fieldType === S_FIELD) { dx = h2; dy = h2; } const x0 = Math.min(Math.floor((x - dx) * h1), this.numX - 2); const tx = ((x - dx) - x0 * this.h) * h1; const x1 = Math.min(x0 + 1, this.numX - 2); const y0 = Math.min(Math.floor((y - dy) * h1), this.numY - 2); const ty = ((y - dy) - y0 * this.h) * h1; const y1 = Math.min(y0 + 1, this.numY - 2); const sx = 1.0 - tx, sy = 1.0 - ty; const val = sx * sy * fieldData[y0][x0] + tx * sy * fieldData[y0][x1] + tx * ty * fieldData[y1][x1] + sx * ty * fieldData[y1][x0]; return val; } advectVel(dt) { const newU = this.u.map(row => [...row]); const newV = this.v.map(row => [...row]); const h2 = 0.5 * this.h; for (let i = 1; i < this.numX - 1; i++) for (let j = 1; j < this.numY - 1; j++) { if (this.s[i][j] !== 0.0 && this.s[i - 1][j] !== 0.0) { const avgV = (this.v[i - 1][j] + this.v[i][j] + this.v[i - 1][j + 1] + this.v[i][j + 1]) * 0.25; let posX = i * this.h, posY = j * this.h + h2; posX -= dt * this.u[i][j]; posY -= dt * avgV; newU[i][j] = this.sampleField(posX, posY, U_FIELD, this.u); } if (this.s[i][j] !== 0.0 && this.s[i][j - 1] !== 0.0) { const avgU = (this.u[i][j - 1] + this.u[i][j] + this.u[i + 1][j - 1] + this.u[i + 1][j]) * 0.25; let posX = i * this.h + h2, posY = j * this.h; posX -= dt * avgU; posY -= dt * this.v[i][j]; newV[i][j] = this.sampleField(posX, posY, V_FIELD, this.v); } } this.u = newU; this.v = newV; } advectSmoke(dt) { const newM = this.m.map(row => [...row]); const h2 = 0.5 * this.h; for (let i = 1; i < this.numX - 1; i++) for (let j = 1; j < this.numY - 1; j++) if (this.s[i][j] !== 0.0) { const avgU = (this.u[i][j] + this.u[i + 1][j]) * 0.5; const avgV = (this.v[i][j] + this.v[i][j + 1]) * 0.5; const x = i * this.h + h2 - dt * avgU; const y = j * this.h + h2 - dt * avgV; newM[i][j] = this.sampleField(x, y, S_FIELD, this.m); } this.m = newM; } simulate(dt, gravity, numIters, overRelaxation, flowVelocity, currentTime) { for (let j = 1; j < this.numY - 1; j++) this.u[1][j] = 0.0; const inletCenterJ = (this.inletMinJ + this.inletMaxJ) / 2.0; const inletHalfWidth = (this.inletMaxJ - this.inletMinJ) / 2.0; const waveFrequency = 2.0, waveAmplitude = 0.4; const timeBasedVelocity = flowVelocity * (1.0 + waveAmplitude * Math.cos(currentTime * waveFrequency)); if (inletHalfWidth > 0) for (let j = this.inletMinJ; j < this.inletMaxJ; j++) { const relativePos = (j - inletCenterJ) / inletHalfWidth; const speed = timeBasedVelocity * (1 - relativePos * relativePos); this.u[1][j] = Math.max(0.0, speed); } for (let j = this.inletMinJ; j < this.inletMaxJ; j++) this.m[1][j] = 0.0; this.integrate(dt, gravity); for (let i = 0; i < this.numX; i++) for (let j = 0; j < this.numY; j++) this.p[i][j] = 0.0; this.solveIncompressibility(numIters, dt, overRelaxation); this.extrapolate(); this.advectVel(dt); this.advectSmoke(dt); } }

            let currentLang = 'en';
            let availableFacts = [];
            let currentGameState = GameState.StartScreen;
            let winner = null, level = 1, animationFrameId = 0, isGameOver = false;
            let levelStartTime = 0, totalTimeMs = 0, finalCompletionTimeMs = 0;
            let fluid = null, ducks = [], obstacles = [], splashes = [];
            let lastObstacleSpawnTime = 0, lastFrameTime = performance.now();
            let CANVAS_WIDTH = 1200, CANVAS_HEIGHT = 300, C_SCALE = 1, SIM_WIDTH = 1;
            let userNickname = 'Guest';

            const screens = { start: document.getElementById('start-screen'), levelComplete: document.getElementById('level-complete-screen'), gameOver: document.getElementById('game-over-screen'), canvasContainer: document.getElementById('game-canvas-container'), finalWin: document.getElementById('final-win-screen'), };
            const canvas = document.getElementById('game-canvas'), ctx = canvas.getContext('2d');
            const gameUi = document.getElementById('game-ui'), startButton = document.getElementById('start-button');
            const nextLevelButton = document.getElementById('next-level-button'), restartButton = document.getElementById('restart-button');
            const levelDisplay = document.getElementById('level-display'), levelCompleteTitle = document.getElementById('level-complete-title');
            const levelCompleteDesc = document.getElementById('level-complete-desc');
            const timeDisplay = document.getElementById('time-display');
            const finalTimeDisplay = document.getElementById('final-time-display'), closeAndSaveButton = document.getElementById('close-and-save-button');
            const factModal = document.getElementById('fact-modal'), factText = document.getElementById('fact-text');
            const closeFactModal = document.getElementById('close-fact-modal'), learnModal = document.getElementById('learn-modal');
            const rankingButton = document.getElementById('ranking-button'), leaderboardModal = document.getElementById('leaderboard-modal');
            const leaderboardContent = document.getElementById('leaderboard-content'), closeLeaderboardModal = document.getElementById('close-leaderboard-modal');
            const gameOverText = document.getElementById('game-over-text');

            function t(key, ...args) { const langDict = translations[currentLang] || translations.en; let value = key.split('.').reduce((obj, k) => (obj && obj[k] !== undefined) ? obj[k] : undefined, langDict); if (typeof value === 'function') return value(...args); return value || key; }
            function updateAllTexts() { document.querySelectorAll('[data-t]').forEach(el => { el.textContent = t(el.dataset.t); }); document.querySelectorAll('[data-t-html]').forEach(el => { el.innerHTML = t(el.dataset.tHtml); }); }
            function formatTime(ms) { const seconds = Math.floor(ms / 1000); const milliseconds = Math.floor(ms % 1000).toString().padStart(3, '0'); return `${seconds}:${milliseconds}`; }
            function showRandomFact() { const currentFacts = facts[currentLang] || facts.en; if (availableFacts.length === 0) availableFacts = [...currentFacts]; const factIndex = Math.floor(Math.random() * availableFacts.length); factText.textContent = availableFacts[factIndex]; availableFacts.splice(factIndex, 1); factModal.classList.remove('hidden'); }
            
            async function fetchAndShowLeaderboard() {
                leaderboardContent.innerHTML = `<p class="text-center">${t('leaderboard.loading')}</p>`;
                leaderboardModal.classList.remove('hidden');
                try {
                    const response = await fetch(`https://flowapp-api.maciej-tadej.workers.dev/api/duck-race?playerName=${encodeURIComponent(userNickname)}`);
                    if (!response.ok) throw new Error('Network response was not ok');
                    const data = await response.json();
                    let html = '<ol class="list-decimal list-inside space-y-2">';
                    data.top10.forEach((entry, index) => {
                        const isCurrentUser = entry.player_name === userNickname;
                        html += `<li class="${isCurrentUser ? 'text-yellow-300 font-bold' : ''}">${index + 1}. ${entry.player_name} - ${formatTime(entry.completion_time_ms)}</li>`;
                    });
                    html += '</ol>';
                    if (data.userRank && (data.userRank.rank > 10 || !data.top10.some(e => e.player_name === userNickname && e.completion_time_ms === data.userRank.time))) {
                        html += `<hr class="my-4 border-gray-600"><div class="text-center mt-4">
                                     <p class="text-lg">${t('leaderboard.yourBest')}</p>
                                     <p class="text-yellow-300 font-bold text-xl">${data.userRank.rank}. ${userNickname} - ${formatTime(data.userRank.time)}</p>
                                 </div>`;
                    }
                    leaderboardContent.innerHTML = html;
                } catch (error) {
                    console.error("Failed to fetch leaderboard:", error);
                    leaderboardContent.innerHTML = `<p class="text-center text-red-400">${t('leaderboard.error')}</p>`;
                }
            }
            
            function createSplash(simX, simY, strength) { splashes.push({ x: simX, y: simY, radius: 10, opacity: 1 }); ducks.forEach(duck => { if (duck.stunned > 0) return; const dx = duck.x - simX, dy = duck.y - simY, dist = Math.hypot(dx, dy); if (dist > 0.01 && dist < SPLASH_EFFECT_RADIUS) { const falloff = 1 - (dist / SPLASH_EFFECT_RADIUS); duck.vx += (dx / dist) * strength * falloff; duck.vy += (dy / dist) * strength * falloff; } }); if (fluid && !isGameOver) { const config = LEVEL_CONFIGS[level - 1]; fluid.simulate(DT / 3, NUM_ITERS / 3, OVER_RELAXATION, config.flow, performance.now() / 1000); } }
            function spawnObstacle() { const config = LEVEL_CONFIGS[level - 1]; const availableTypes = config.types; const obstacleType = availableTypes[Math.floor(Math.random() * availableTypes.length)]; obstacles.push({ id: Date.now() + Math.random(), x: -0.1 * SIM_WIDTH, y: RIVERBANK_MARGIN + (SIM_HEIGHT - 2 * RIVERBANK_MARGIN) * Math.random(), vx: 0, vy: 0, width: 0.08 + Math.random() * 0.07, height: 0.03 + Math.random() * 0.02, angle: Math.random() * Math.PI * 2, type: obstacleType }); }
            function initializeGame() { isGameOver = false; splashes = []; levelStartTime = performance.now(); const rect = canvas.getBoundingClientRect(); canvas.width = rect.width; canvas.height = rect.height; CANVAS_WIDTH = canvas.width; CANVAS_HEIGHT = canvas.height; C_SCALE = CANVAS_HEIGHT / SIM_HEIGHT; SIM_WIDTH = CANVAS_WIDTH / C_SCALE; const h = SIM_HEIGHT / RESOLUTION, numY = RESOLUTION, numX = Math.floor(SIM_WIDTH / h); fluid = new FluidSimulator(1000.0, numX, numY, h); ducks = []; const playerNames = ['You', 'Duck Alice', 'Duck Bob'], playerColors = ['#FFD700', '#FF69B4', '#00BFFF']; const takenPositions = new Set(); for (let i = 0; i < NUM_PLAYERS; i++) { const startX = 0.1 * SIM_WIDTH; let startY; do { startY = RIVERBANK_MARGIN + (SIM_HEIGHT - 2 * RIVERBANK_MARGIN) * (0.1 + Math.random() * 0.8); } while (takenPositions.has(Math.floor(startY * 10))); takenPositions.add(Math.floor(startY * 10)); ducks.push({ id: i, name: playerNames[i], x: startX, y: startY, startX, startY, vx: 0, vy: 0, color: playerColors[i], type: i === 0 ? PlayerType.Human : PlayerType.Bot, stunned: 0 }); } obstacles = []; lastObstacleSpawnTime = performance.now(); }
            function draw() { if (!ctx) return; ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); const config = LEVEL_CONFIGS[level-1]; const bankTopY = RIVERBANK_MARGIN * C_SCALE, bankBottomY = CANVAS_HEIGHT - RIVERBANK_MARGIN * C_SCALE, waveAmplitude = 8, waveLength = 100; ctx.fillStyle = '#228B22'; ctx.beginPath(); ctx.moveTo(0, 0); for (let x = 0; x <= CANVAS_WIDTH; x += 10) ctx.lineTo(x, bankTopY + Math.sin(x / waveLength) * waveAmplitude); ctx.lineTo(CANVAS_WIDTH, 0); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(0, CANVAS_HEIGHT); for (let x = 0; x <= CANVAS_WIDTH; x += 10) ctx.lineTo(x, bankBottomY + Math.sin(x / waveLength + Math.PI) * waveAmplitude); ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT); ctx.closePath(); ctx.fill(); if (fluid) { const h = fluid.h; for (let i = 0; i < fluid.numX; i++) for (let j = 0; j < fluid.numY; j++) { const alpha = (1 - fluid.m[i][j]) * 0.15; if (alpha > 0.01) { ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`; ctx.fillRect(i * h * C_SCALE, j * h * C_SCALE, h * C_SCALE, h * C_SCALE); } } } obstacles.forEach(obs => { ctx.save(); ctx.translate(obs.x * C_SCALE, obs.y * C_SCALE); ctx.rotate(obs.angle); if (obs.type === ObstacleType.Log) { ctx.fillStyle = '#8B4513'; ctx.fillRect(-obs.width / 2 * C_SCALE, -obs.height / 2 * C_SCALE, obs.width * C_SCALE, obs.height * C_SCALE); } else { ctx.fillStyle = '#556B2F'; ctx.beginPath(); ctx.arc(0, 0, obs.width / 2 * C_SCALE, 0, Math.PI * 2); ctx.fill(); } ctx.restore(); }); splashes.forEach(splash => { ctx.strokeStyle = `rgba(255, 255, 255, ${splash.opacity})`; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(splash.x * C_SCALE, splash.y * C_SCALE, splash.radius, 0, 2 * Math.PI); ctx.stroke(); }); ducks.forEach(duck => { ctx.save(); ctx.translate(duck.x * C_SCALE, duck.y * C_SCALE); ctx.rotate(Math.atan2(duck.vy, duck.vx)); ctx.fillStyle = duck.color; ctx.beginPath(); ctx.arc(0, 0, DUCK_SIZE, 0, 2 * Math.PI); ctx.fill(); ctx.fillStyle = '#FFA500'; ctx.beginPath(); ctx.moveTo(DUCK_SIZE - 2, 0); ctx.lineTo(DUCK_SIZE + 10, -4); ctx.lineTo(DUCK_SIZE + 10, 4); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#000000'; ctx.beginPath(); ctx.arc(DUCK_SIZE / 2, -DUCK_SIZE / 3, 2, 0, 2 * Math.PI); ctx.fill(); if (duck.stunned > 0) { ctx.strokeStyle = '#333'; ctx.lineWidth = 1.5; ctx.beginPath(); ctx.arc(0, -DUCK_SIZE, DUCK_SIZE * 0.8, Math.PI * 1.5, Math.PI * 1.5 + (Math.PI * 2 * (duck.stunned / STUN_DURATION))); ctx.stroke(); } ctx.restore(); }); if (config.hasFog) { const fogX = FOG_START_X * CANVAS_WIDTH; const gradient = ctx.createLinearGradient(fogX, 0, CANVAS_WIDTH, 0); gradient.addColorStop(0, 'rgba(200, 200, 220, 0.0)'); gradient.addColorStop(0.3, 'rgba(200, 200, 220, 0.7)'); gradient.addColorStop(1, 'rgba(200, 200, 220, 0.9)'); ctx.fillStyle = gradient; ctx.fillRect(fogX, 0, CANVAS_WIDTH - fogX, CANVAS_HEIGHT); } ctx.strokeStyle = 'red'; ctx.lineWidth = 3; ctx.setLineDash([10, 10]); ctx.beginPath(); const finishLineCanvasX = FINISH_LINE_X * CANVAS_WIDTH; ctx.moveTo(finishLineCanvasX, 0); ctx.lineTo(finishLineCanvasX, CANVAS_HEIGHT); ctx.stroke(); ctx.setLineDash([]); }
            function update(currentTime) { if (isGameOver || !fluid) { animationFrameId = requestAnimationFrame(update); return; } const deltaTime = (currentTime - lastFrameTime) / 1000; lastFrameTime = currentTime; const config = LEVEL_CONFIGS[level - 1]; const elapsedTimeMs = performance.now() - levelStartTime; timeDisplay.textContent = formatTime(elapsedTimeMs); splashes = splashes.map(s => ({ ...s, radius: s.radius + SPLASH_RADIUS_RATE * deltaTime, opacity: s.opacity - SPLASH_OPACITY_RATE * deltaTime, })).filter(s => s.opacity > 0); fluid.simulate(DT, 0, NUM_ITERS, OVER_RELAXATION, config.flow, currentTime / 1000.0); if (currentTime - lastObstacleSpawnTime > config.spawnRate && obstacles.length < config.maxObs) { spawnObstacle(); lastObstacleSpawnTime = currentTime; } ducks.forEach(duck => { if (duck.stunned > 0) { duck.stunned = Math.max(0, duck.stunned - deltaTime); duck.vx *= 0.95; duck.vy *= 0.95; } else if (duck.type === PlayerType.Bot) { let actionTaken = false; const otherDucks = ducks.filter(d => d.id !== duck.id); const target = otherDucks.find(d => d.x > duck.x && (d.x - duck.x) < BOT_OFFENSIVE_RANGE && Math.abs(d.y - duck.y) < BOT_OFFENSIVE_RANGE / 2); if (target && Math.random() < BOT_OFFENSIVE_CHANCE) { createSplash(target.x + 0.1, target.y, BOT_SPLASH_STRENGTH * 0.8); actionTaken = true; } if (!actionTaken) { const obstaclesInPath = obstacles.filter(obs => obs.x > duck.x && (obs.x - duck.x) < BOT_AVOID_DISTANCE).sort((a, b) => (a.x - duck.x) - (b.x - duck.x)); if (obstaclesInPath.length > 0) { const closestObstacle = obstaclesInPath[0], predictionTime = 0.5, duckFutureY = duck.y + duck.vy * predictionTime, obsFutureY = closestObstacle.y + closestObstacle.vy * predictionTime; if (Math.abs(duckFutureY - obsFutureY) < (DUCK_SIZE / C_SCALE + closestObstacle.height / 2)) { const pushDirectionY = duck.y < obsFutureY ? -1 : 1, splashOffsetY = -pushDirectionY * 0.15; createSplash(duck.x - 0.1, duck.y + splashOffsetY, BOT_SPLASH_STRENGTH * 1.2); actionTaken = true; } } } if (!actionTaken) { const leadingDuckX = Math.max(...ducks.map(d => d.x)); if (duck.x < leadingDuckX - 0.05 * SIM_WIDTH || duck.x < SIM_WIDTH * 0.2) { const splashX = duck.x - 0.15, steerDirection = Math.sign(SIM_HEIGHT / 2 - duck.y), splashY = duck.y - steerDirection * 0.1; createSplash(splashX, splashY, BOT_SPLASH_STRENGTH); } } } duck.vx += fluid.sampleField(duck.x, duck.y, 0, fluid.u) * FLUID_FORCE_FACTOR; duck.vy += fluid.sampleField(duck.x, duck.y, 1, fluid.v) * FLUID_FORCE_FACTOR; duck.vx *= DAMPING_FACTOR; duck.vy *= DAMPING_FACTOR; duck.x += duck.vx * DT; duck.y += duck.vy * DT; if (duck.y < RIVERBANK_MARGIN) { duck.y = RIVERBANK_MARGIN; duck.vy *= -0.5; } if (duck.y > SIM_HEIGHT - RIVERBANK_MARGIN) { duck.y = SIM_HEIGHT - RIVERBANK_MARGIN; duck.vy *= -0.5; } }); obstacles = obstacles.filter(obs => obs.x < SIM_WIDTH * 1.1); obstacles.forEach(obs => { obs.vx += fluid.sampleField(obs.x, obs.y, 0, fluid.u) * OBSTACLE_FLUID_FORCE_FACTOR; obs.vy += fluid.sampleField(obs.x, obs.y, 1, fluid.v) * OBSTACLE_FLUID_FORCE_FACTOR; obs.vx *= 0.99; obs.vy *= 0.99; obs.x += obs.vx * DT; obs.y += obs.vy * DT; }); for (const duck of ducks) for (const obs of obstacles) if (Math.hypot(duck.x - obs.x, duck.y - obs.y) < (DUCK_SIZE / C_SCALE + obs.width / 2)) { if (obs.type === ObstacleType.Log) { duck.stunned = STUN_DURATION; duck.vx *= -0.5; } else if (obs.type === ObstacleType.Garbage) { duck.x = duck.startX; duck.y = duck.startY; duck.vx = 0; duck.vy = 0; duck.stunned = STUN_DURATION; } } const winnerDuck = ducks.find(d => d.x / SIM_WIDTH >= FINISH_LINE_X); if (winnerDuck) { handleGameEnd(winnerDuck.name); return; } draw(); animationFrameId = requestAnimationFrame(update); }
            function handleGameEnd(winnerName) { isGameOver = true; cancelAnimationFrame(animationFrameId); winner = winnerName; const levelTime = performance.now() - levelStartTime; totalTimeMs += levelTime; if (winnerName === 'You' && level < MAX_LEVEL) { currentGameState = GameState.LevelComplete; updateUI(levelTime / 1000); } else if (winnerName === 'You' && level === MAX_LEVEL) { currentGameState = GameState.FinalWin; finalCompletionTimeMs = Math.round(totalTimeMs); finalTimeDisplay.textContent = formatTime(finalCompletionTimeMs); updateUI(); } else { currentGameState = GameState.GameOver; updateUI(totalTimeMs / 1000); } }
            function updateUI(finalTimeInSeconds = 0) { Object.values(screens).forEach(s => s.classList.add('hidden')); const mainOverlay = document.getElementById('main-overlay'); mainOverlay.style.backdropFilter = 'blur(4px)'; switch (currentGameState) { case GameState.StartScreen: screens.start.classList.remove('hidden'); mainOverlay.style.backdropFilter = 'blur(8px)'; break; case GameState.LevelComplete: screens.levelComplete.classList.remove('hidden'); levelCompleteTitle.textContent = t('levelComplete', level); const nextLevel = level + 1; levelCompleteDesc.textContent = t('nextLevelDesc', nextLevel); nextLevelButton.textContent = t('nextLevelButton', nextLevel); break; case GameState.GameOver: screens.gameOver.classList.remove('hidden'); gameOverText.textContent = winner?.startsWith('Duck') ? t('gameOverBotWon', winner) : t('gameOverLost'); break; case GameState.FinalWin: screens.finalWin.classList.remove('hidden'); break; case GameState.Playing: screens.canvasContainer.classList.remove('hidden'); mainOverlay.style.backdropFilter = 'none'; const config = LEVEL_CONFIGS[level - 1]; levelDisplay.textContent = `Level ${config.level}: ${config.name}`; break; } }
            function startGameFlow() { currentGameState = GameState.Playing; updateUI(); initializeGame(); lastFrameTime = performance.now(); if(animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = requestAnimationFrame(update); }
            function startGame() { level = 1; totalTimeMs = 0; const factsForLang = facts[currentLang] || facts.en; availableFacts = [...(factsForLang || [])]; startGameFlow(); };
            const restartGame = () => { showRandomFact(); startGame(); };
            const startNextLevel = () => { level++; startGameFlow(); };

            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', restartGame);
            nextLevelButton.addEventListener('click', startNextLevel);
            closeAndSaveButton.addEventListener('click', () => { window.parent.postMessage({ type: 'gameTime', completion_time_ms: finalCompletionTimeMs, language: currentLang }, '*'); });
            canvas.addEventListener('click', (e) => { if (currentGameState !== GameState.Playing) return; const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width, scaleY = canvas.height / rect.height; const simX = (e.clientX - rect.left) * scaleX / C_SCALE, simY = (e.clientY - rect.top) * scaleY / C_SCALE; const clickedObstacleIdx = obstacles.findIndex(obs => Math.hypot(simX - obs.x, simY - obs.y) < obs.width / 2); if (clickedObstacleIdx !== -1) { obstacles.splice(clickedObstacleIdx, 1); return; } createSplash(simX, simY, SPLASH_STRENGTH); });
            document.querySelectorAll('.lang-btn').forEach(button => { button.addEventListener('click', () => { currentLang = button.dataset.lang; document.querySelector('.lang-btn.active').classList.remove('active'); button.classList.add('active'); updateAllTexts(); }); });
            document.getElementById('learn-button').addEventListener('click', () => learnModal.classList.remove('hidden'));
            document.getElementById('close-learn-modal').addEventListener('click', () => learnModal.classList.add('hidden'));
            closeFactModal.addEventListener('click', () => factModal.classList.add('hidden'));
            rankingButton.addEventListener('click', fetchAndShowLeaderboard);
            closeLeaderboardModal.addEventListener('click', () => leaderboardModal.classList.add('hidden'));
            
            let resizeTimeout;
            window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { if(currentGameState === GameState.Playing) { initializeGame(); } }, 250); });
            
            const urlParams = new URLSearchParams(window.location.search);
            userNickname = urlParams.get('nickname') || 'Guest';
            document.querySelector('.lang-btn[data-lang="en"]').classList.add('active');
            updateAllTexts();
            updateUI();
        });
    </script>
</body>
</html>
